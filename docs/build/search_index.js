var documenterSearchIndex = {"docs":
[{"location":"timestepping.html#Time-Integration","page":"Time Integration","title":"Time Integration","text":"","category":"section"},{"location":"timestepping.html","page":"Time Integration","title":"Time Integration","text":"Geodynamo.jl offers three production-grade time-integration strategies. All rely on the shared Krylov/ETD utilities in timestep.jl and respect PencilArray domain decompositions.","category":"page"},{"location":"timestepping.html#CNAB2-(Crank–Nicolson-Adams–Bashforth-2)","page":"Time Integration","title":"CNAB2 (Crank–Nicolson Adams–Bashforth 2)","text":"","category":"section"},{"location":"timestepping.html","page":"Time Integration","title":"Time Integration","text":"Type: IMEX second-order scheme.\nLinear part: Treated implicitly with θ-weighting (d_implicit).\nNonlinear part: Advanced using Adams–Bashforth with history buffers.\nImplementation:\nBuild RHS via build_rhs_cnab2!, which incorporates (1-θ)L uⁿ and nonlinear extrapolation.\nSolve (I - θΔt L) uⁿ⁺¹ = rhs using banded LU factorisations stored in SHTnsImplicitMatrices.","category":"page"},{"location":"timestepping.html","page":"Time Integration","title":"Time Integration","text":"CNAB2 is robust and favoured for production runs. Keep d_implicit = 0.5 unless you need stronger damping of the linear part.","category":"page"},{"location":"timestepping.html#EAB2-(Exponential-Adams–Bashforth-2)","page":"Time Integration","title":"EAB2 (Exponential Adams–Bashforth 2)","text":"","category":"section"},{"location":"timestepping.html","page":"Time Integration","title":"Time Integration","text":"Type: Exponential integrator using φ-functions.\nLinear handling: Precompute exp(ΔtA) and φ₁(ΔtA) per spherical harmonic degree (or evaluate via Krylov actions).\nNonlinear history: Uses AB2 weights with the ETD basis.\nUtilities:\ncreate_etd_cache – dense matrices for small nr (single-node runs).\neab2_update_krylov_cached! – action-only variant with cached banded LUs for each ℓ.","category":"page"},{"location":"timestepping.html","page":"Time Integration","title":"Time Integration","text":"Use EAB2 when the linear term dominates and you need larger Δt without sacrificing stability. Tune i_etd_m and d_krylov_tol for the Arnoldi accuracy (20/1e-8 is a good starting point).","category":"page"},{"location":"timestepping.html#ERK2-(Exponential-Runge–Kutta-2)","page":"Time Integration","title":"ERK2 (Exponential Runge–Kutta 2)","text":"","category":"section"},{"location":"timestepping.html","page":"Time Integration","title":"Time Integration","text":"Type: Two-stage exponential RK with midpoint evaluation.\nStage 1: k₁ = φ₁(ΔtA) N(uⁿ) using cached φ₁ and exponentials.\nStage 2: Build half-step state via E(Δt/2) and update nonlinear terms.\nFinal update:\nuⁿ⁺¹ = E(Δt) uⁿ + Δt k₁ + Δt φ₂(ΔtA) [N(uⁿ+½) - N(uⁿ)]\nImplementation helpers: ERK2Cache, ERK2FieldBuffers, erk2_prepare_field!, erk2_finalize_field!.","category":"page"},{"location":"timestepping.html","page":"Time Integration","title":"Time Integration","text":"ERK2 is the most accurate of the three but also the most expensive due to the additional φ₂ evaluations. Use when transient accuracy is critical (e.g., wave studies).","category":"page"},{"location":"timestepping.html#ERK2-Cache-Management-and-Diagnostics","page":"Time Integration","title":"ERK2 Cache Management and Diagnostics","text":"","category":"section"},{"location":"timestepping.html","page":"Time Integration","title":"Time Integration","text":"Precompute caches: Run julia --project scripts/precompute_erk2_caches.jl --dt=Δt --fields=temperature,vel_tor to build dense ERK2 caches ahead of time. The script saves a JLD2 bundle; load it via load_erk2_cache_bundle!(state.erk2_caches, \"erk2_caches.jld2\") before advancing timesteps.\nMetadata: Bundles store solver metadata (Δt, geometry, Arnoldi controls) so you can verify compatibility when restarting a long production run.\nRuntime hooks: Enable stage diagnostics with Geodynamo.enable_erk2_diagnostics!(interval=10) or set GEODYNAMO_ERK2_DIAGNOSTICS=true in the environment. The integrator logs the max and L₂ residual norms of N(uⁿ+½) - N(uⁿ) at the desired cadence.\nCustom analysis: Use erk2_stage_residual_stats(buffers) if you need bespoke monitoring or to feed the residual signal into adaptive control logic.","category":"page"},{"location":"timestepping.html#Krylov-Action-Utilities","page":"Time Integration","title":"Krylov Action Utilities","text":"","category":"section"},{"location":"timestepping.html","page":"Time Integration","title":"Time Integration","text":"All exponential schemes rely on the shared Krylov operators:","category":"page"},{"location":"timestepping.html","page":"Time Integration","title":"Time Integration","text":"exp_action_krylov(Aop!, v, Δt) – computes exp(ΔtA) v using an Arnoldi basis.\nphi1_action_krylov(Aop!, A_lu, v, Δt) – evaluates φ₁ via banded solves and Krylov exponentials.\nget_eab2_alu_cache! – caches banded matrices and LU factorizations per ℓ for action-based updates.","category":"page"},{"location":"timestepping.html","page":"Time Integration","title":"Time Integration","text":"Use a consistent m (i_etd_m) across your run to amortise Arnoldi setup costs and avoid dimension mismatches.","category":"page"},{"location":"timestepping.html#Adaptive-Timesteps","page":"Time Integration","title":"Adaptive Timesteps","text":"","category":"section"},{"location":"timestepping.html","page":"Time Integration","title":"Time Integration","text":"compute_cfl_timestep! estimates an explicit CFL-bound based on velocity magnitudes. Combine it with d_courant to limit Δt dynamically. Future releases will integrate error-based controllers for the ETD schemes.","category":"page"},{"location":"timestepping.html#Practical-Recommendations","page":"Time Integration","title":"Practical Recommendations","text":"","category":"section"},{"location":"timestepping.html","page":"Time Integration","title":"Time Integration","text":"Scenario Suggested Scheme Notes\nProduction shell dynamo CNAB2 Reliable; monitor nonlinear history to avoid startup transients.\nStrong diffusion / linear damping EAB2 Larger Δt possible; ensure i_etd_m ≥ 20 for nr ≥ 128.\nWave / transient studies ERK2 Most accurate; cache reuse essential for performance.","category":"page"},{"location":"timestepping.html","page":"Time Integration","title":"Time Integration","text":"Always pre-warm the nonlinear history (prev_nonlinear buffers) on the first step as shown in apply_master_implicit_step!.","category":"page"},{"location":"api.html#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"The table below lists the main entry points exported by Geodynamo. The listing is automatically generated during the documentation build.","category":"page"},{"location":"api.html#Main-Module","page":"API Reference","title":"Main Module","text":"","category":"section"},{"location":"api.html#Geodynamo.AbstractScalarField","page":"API Reference","title":"Geodynamo.AbstractScalarField","text":"Abstract type for scalar fields (temperature, composition, etc.)\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.AdvancedThreadManager","page":"API Reference","title":"Geodynamo.AdvancedThreadManager","text":"AdvancedThreadManager\n\nAdvanced thread management with CPU affinity, NUMA awareness, and work-stealing.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.AsyncCommManager","page":"API Reference","title":"Geodynamo.AsyncCommManager","text":"AsyncCommManager{T}\n\nAdvanced asynchronous communication manager for overlapping computation and communication.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.CPUParallelizer","page":"API Reference","title":"Geodynamo.CPUParallelizer","text":"CPUParallelizer{T}\n\nAdvanced CPU parallelization system with SIMD, NUMA, and task-based parallelism.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.CombinerConfig","page":"API Reference","title":"Geodynamo.CombinerConfig","text":"CombinerConfig\n\nConfiguration structure for field combination process.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.DynamicLoadBalancer","page":"API Reference","title":"Geodynamo.DynamicLoadBalancer","text":"DynamicLoadBalancer\n\nDynamic load balancing system that adapts to computational heterogeneity.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.ERK2Cache","page":"API Reference","title":"Geodynamo.ERK2Cache","text":"ERK2Cache{T}\n\nCached data structure for Exponential 2nd Order Runge-Kutta method. Stores precomputed matrix exponentials and φ functions for each spherical harmonic mode.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.FieldCombiner","page":"API Reference","title":"Geodynamo.FieldCombiner","text":"FieldCombiner{T}\n\nStructure for combining distributed Geodynamo.jl output files using the  consistent field structures and parameter system.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.HybridParallelizer","page":"API Reference","title":"Geodynamo.HybridParallelizer","text":"HybridParallelizer{T}\n\nCoordinates MPI and threads for maximum CPU parallelization.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.MasterParallelizer","page":"API Reference","title":"Geodynamo.MasterParallelizer","text":"MasterParallelizer{T}\n\nComprehensive parallelization system combining all techniques.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.MemoryOptimizer","page":"API Reference","title":"Geodynamo.MemoryOptimizer","text":"MemoryOptimizer{T}\n\nAdvanced memory management with cache optimization and NUMA awareness.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.ParallelIOOptimizer","page":"API Reference","title":"Geodynamo.ParallelIOOptimizer","text":"ParallelIOOptimizer{T}\n\nAdvanced parallel I/O optimization with asynchronous writes and data staging.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.PerformanceMonitor","page":"API Reference","title":"Geodynamo.PerformanceMonitor","text":"PerformanceMonitor\n\nComprehensive performance monitoring for parallel efficiency analysis.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.SIMDOptimizer","page":"API Reference","title":"Geodynamo.SIMDOptimizer","text":"SIMDOptimizer{T}\n\nAdvanced SIMD vectorization for mathematical operations with AVX/NEON support.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.SimulationState","page":"API Reference","title":"Geodynamo.SimulationState","text":"SimulationState{T}\n\nUnified simulation state with comprehensive parallelization and diagnostics.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.SpectralToPhysicalConverter","page":"API Reference","title":"Geodynamo.SpectralToPhysicalConverter","text":"SpectralToPhysicalConverter{T}\n\nStructure for converting spectral field data to physical space using the Geodynamo.jl infrastructure (PencilArrays + SHTns).\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.TaskGraph","page":"API Reference","title":"Geodynamo.TaskGraph","text":"TaskGraph\n\nRepresents computation as a directed acyclic graph for optimal scheduling.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.TaskNode","page":"API Reference","title":"Geodynamo.TaskNode","text":"TaskNode\n\nRepresents a computation task in a dependency graph.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.ThreadingAccelerator","page":"API Reference","title":"Geodynamo.ThreadingAccelerator","text":"ThreadingAccelerator{T} (Backward Compatibility)\n\nBasic CPU threading acceleration for existing code.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo._get_influence_cache-Tuple{RadialDomain, Any}","page":"API Reference","title":"Geodynamo._get_influence_cache","text":"_get_influence_cache(domain::RadialDomain, dr_matrix)\n\nGet or create cached influence functions and matrix for given domain. Note: drmatrix should be a BandedMatrix (defined in linearalgebra.jl)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo._get_tau_cache-Tuple{RadialDomain}","page":"API Reference","title":"Geodynamo._get_tau_cache","text":"_get_tau_cache(domain::RadialDomain)\n\nGet or create cached tau polynomials and derivatives for given domain.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.add_internal_sources_local!-Union{Tuple{T}, Tuple{Geodynamo.AbstractScalarField{T}, RadialDomain}} where T","page":"API Reference","title":"Geodynamo.add_internal_sources_local!","text":"add_internal_sources_local!(field::AbstractScalarField{T}, domain::RadialDomain) where T\n\nAdd volumetric sources (completely local operation). This works for any scalar field with radial source profile.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.analyze_load_balance-Tuple{PencilArrays.Pencils.Pencil}","page":"API Reference","title":"Geodynamo.analyze_load_balance","text":"analyze_load_balance(pencil::Pencil)\n\nAnalyze and report load balance for a given pencil decomposition.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.apply_banded_full!-Union{Tuple{T}, Tuple{Vector{T}, BandedMatrix{T}, Vector{T}}} where T","page":"API Reference","title":"Geodynamo.apply_banded_full!","text":"apply_banded_full!(out, B, v)\n\nApply banded matrix to full vector.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.apply_composition_boundary_conditions!-Union{Tuple{SHTnsCompositionField{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.apply_composition_boundary_conditions!","text":"apply_composition_boundary_conditions!(field; time_index=nothing)\n\nRefresh composition boundary values from the BoundaryConditions subsystem and enforce Dirichlet data in spectral space.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.apply_enhanced_implicit_step!-Union{Tuple{T}, Tuple{SimulationState{T}, Float64}} where T","page":"API Reference","title":"Geodynamo.apply_enhanced_implicit_step!","text":"apply_enhanced_implicit_step!(state, dt)\n\nApply enhanced implicit time integration with advanced solvers.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.apply_flux_bc_direct!-Tuple{Any, Any, Any, Any, Geodynamo.AbstractScalarField, Any, Any}","page":"API Reference","title":"Geodynamo.apply_flux_bc_direct!","text":"apply_flux_bc_direct!(spec_real, spec_imag, local_lm, lm_idx,\n                     field::AbstractScalarField, domain, r_range)\n\nDirect modification of boundary values to approximately satisfy flux BC. This is the simplest but least accurate method.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.apply_flux_bc_influence_matrix!-Tuple{Any, Any, Any, Any, Any, Any, Geodynamo.AbstractScalarField, Any, Any}","page":"API Reference","title":"Geodynamo.apply_flux_bc_influence_matrix!","text":"apply_flux_bc_influence_matrix!(spec_real, spec_imag, local_lm, lm_idx,\n                               apply_inner, apply_outer, field::AbstractScalarField,\n                               domain, r_range)\n\nApply flux boundary conditions using the influence matrix method.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.apply_flux_bc_spectral!-Union{Tuple{T}, Tuple{SHTnsTemperatureField{T}, RadialDomain}} where T","page":"API Reference","title":"Geodynamo.apply_flux_bc_spectral!","text":"apply_flux_bc_spectral_complete!(temp_field, domain)\n\nComplete implementation of flux boundary conditions in spectral space. This modifies the spectral coefficients to satisfy ∂T/∂r = prescribed_flux.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.apply_flux_bc_tau!-Tuple{Any, Any, Any, Any, Any, Any, Geodynamo.AbstractScalarField, Any, Any}","page":"API Reference","title":"Geodynamo.apply_flux_bc_tau!","text":"apply_flux_bc_tau!(spec_real, spec_imag, local_lm, lm_idx, \n                   apply_inner, apply_outer, field::AbstractScalarField, \n                   domain, r_range)\n\nApply flux boundary conditions using the tau method. This is the generalized version that works with any scalar field.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.apply_geometric_factors_spectral!-Union{Tuple{T}, Tuple{Geodynamo.AbstractScalarField{T}, RadialDomain}} where T","page":"API Reference","title":"Geodynamo.apply_geometric_factors_spectral!","text":"apply_geometric_factors_spectral!(field::AbstractScalarField{T}, domain::RadialDomain) where T\n\nApply geometric factors (1/r, 1/(r sin θ)) in spectral space. For gradients in spherical coordinates. This is generic.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.apply_magnetic_boundary_conditions!-Union{Tuple{SHTnsMagneticFields{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.apply_magnetic_boundary_conditions!","text":"apply_magnetic_boundary_conditions!(fields; time_index=nothing)\n\nRefresh magnetic boundary data from the BoundaryConditions subsystem and enforce the corresponding Dirichlet values in spectral space.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.apply_scalar_flux_bc_spectral!-Union{Tuple{T}, Tuple{Geodynamo.AbstractScalarField{T}, RadialDomain}} where T","page":"API Reference","title":"Geodynamo.apply_scalar_flux_bc_spectral!","text":"apply_scalar_flux_bc_spectral!(field::AbstractScalarField{T}, domain::RadialDomain;\n                               method::Symbol=:tau) where T\n\nApply flux boundary conditions to a scalar field in spectral space. Methods available: :tau (most robust), :influence_matrix, :direct (simplest).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.apply_tau_correction!-Union{Tuple{T}, Tuple{Vector{T}, Any, RadialDomain}} where T","page":"API Reference","title":"Geodynamo.apply_tau_correction!","text":"apply_tau_correction!(profile::Vector{T}, tau_coeffs, domain::RadialDomain) where T\n\nAdd tau correction to the radial profile.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.apply_velocity_boundary_conditions!-Union{Tuple{SHTnsVelocityFields{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.apply_velocity_boundary_conditions!","text":"apply_velocity_boundary_conditions!(fields; time_index=nothing)\n\nRefresh velocity boundary data from the BoundaryConditions subsystem and immediately enforce Dirichlet constraints in spectral space.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.batch_convert_directory-Union{Tuple{String}, Tuple{T}, Tuple{String, String}} where T","page":"API Reference","title":"Geodynamo.batch_convert_directory","text":"batch_convert_directory(input_dir::String, output_dir::String = \"\";\n                       pattern::String = \"combined_global_time_\",\n                       precision::Type{T} = Float64,\n                       compute_diagnostics::Bool = true) where T\n\nConvert all spectral files matching a pattern in a directory.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.batch_magnetic_transforms!-Union{Tuple{SHTnsMagneticFields{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.batch_magnetic_transforms!","text":"batch_magnetic_transforms!(mag_fields::SHTnsMagneticFields{T}) where T\n\nPerform batched transforms for better cache efficiency using shtnskit_transforms.jl\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.batch_shtnskit_transforms!-Union{Tuple{T}, Tuple{Array{SHTnsSpectralField{T}, 1}, Array{SHTnsPhysicalField{T}, 1}}} where T","page":"API Reference","title":"Geodynamo.batch_shtnskit_transforms!","text":"batch_shtnskit_transforms!(specs::Vector{SHTnsSpectralField{T}},\n                          physs::Vector{SHTnsPhysicalField{T}}) where T\n\nBatch process multiple transforms using SHTnsKit with PencilArrays.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.batch_spectral_to_physical!-Union{Tuple{T}, Tuple{Array{SHTnsSpectralField{T}, 1}, Array{SHTnsPhysicalField{T}, 1}}} where T","page":"API Reference","title":"Geodynamo.batch_spectral_to_physical!","text":"batch_spectral_to_physical!(specs, physs)\n\nCompatibility wrapper that calls batch_shtnskit_transforms! for batched spectral→physical transforms using SHTnsKit with PencilArrays/MPI.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.batch_velocity_transforms!-Union{Tuple{SHTnsVelocityFields{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.batch_velocity_transforms!","text":"batch_velocity_transforms!(fields::SHTnsVelocityFields{T}) where T\n\nPerform batched transforms for better cache efficiency using shtnskit_transforms.jl\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.batch_write_spectral_fields!-Tuple{Any, Dict{String, Any}, OutputConfig, FieldInfo}","page":"API Reference","title":"Geodynamo.batch_write_spectral_fields!","text":"batch_write_spectral_fields!(nc_file, fields::Dict, config::OutputConfig, field_info::FieldInfo)\n\nWrite multiple spectral fields in batched operations for better I/O performance\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.build_banded_A-Union{Tuple{T}, Tuple{Type{T}, RadialDomain, Float64, Int64}} where T","page":"API Reference","title":"Geodynamo.build_banded_A","text":"build_banded_A(T, domain, diffusivity, l) -> BandedMatrix{T}\n\nConstruct banded A = ν*(d²/dr² + (2/r)d/dr − l(l+1)/r²) in banded storage.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.build_influence_matrix-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Any, RadialDomain}} where T","page":"API Reference","title":"Geodynamo.build_influence_matrix","text":"build_influence_matrix(G_inner, G_outer, dr_matrix, domain)\n\nConstruct a 2×2 matrix mapping influence amplitudes to boundary flux errors. Rows correspond to (inner, outer) boundaries; columns to (inner, outer) influence functions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.build_rhs_cnab2!-Union{Tuple{T}, Tuple{SHTnsSpectralField{T}, SHTnsSpectralField{T}, SHTnsSpectralField{T}, SHTnsSpectralField{T}, Float64, SHTnsImplicitMatrices{T}}} where T","page":"API Reference","title":"Geodynamo.build_rhs_cnab2!","text":"build_rhs_cnab2!(rhs, un, nl, nl_prev, dt, matrices)\n\nBuild RHS for CNAB2 IMEX: rhs = un/dt + (1-θ)·L·un + (3/2)·nl − (1/2)·nl_prev, where θ = matrices.theta and L is the diffusivity-scaled linear operator.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.build_theta_derivative_matrix-Union{Tuple{T}, Tuple{Type{T}, SHTnsKitConfig}} where T","page":"API Reference","title":"Geodynamo.build_theta_derivative_matrix","text":"build_theta_derivative_matrix(::Type{T}, config::SHTnsKitConfig) where T\n\nBuild sparse matrix for θ-derivatives in spectral space. This matrix couples different l modes with the same m.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.calculate_linear_neighbors-Tuple{Int64, Int64, Tuple, Symbol}","page":"API Reference","title":"Geodynamo.calculate_linear_neighbors","text":"calculate_linear_neighbors(rank::Int, dim::Int, proc_dims::Tuple, boundaries::Symbol)\n\nCalculate neighbor ranks for non-Cartesian topologies.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.combine_distributed_time-Union{Tuple{T}, Tuple{String, Float64}} where T","page":"API Reference","title":"Geodynamo.combine_distributed_time","text":"combine_distributed_time(output_dir::String, time::Float64; \n                        config::CombinerConfig = create_combiner_config(),\n                        precision::Type{T} = Float64) where T\n\nMain function to combine distributed files for a specific time.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.combine_magnetic_spectral!-Union{Tuple{T}, Tuple{FieldCombiner{T}, Dict}} where T","page":"API Reference","title":"Geodynamo.combine_magnetic_spectral!","text":"combine_magnetic_spectral!(combiner::FieldCombiner{T}, lm_mapping::Dict) where T\n\nCombine magnetic spectral coefficients from all distributed files.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.combine_physical_fields!-Union{Tuple{FieldCombiner{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.combine_physical_fields!","text":"combine_physical_fields!(combiner::FieldCombiner{T}) where T\n\nCombine physical space temperature field from distributed files.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.combine_spectral_fields!-Union{Tuple{FieldCombiner{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.combine_spectral_fields!","text":"combine_spectral_fields!(combiner::FieldCombiner{T}) where T\n\nCombine spectral field data from distributed files.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.combine_time_series-Union{Tuple{T}, Tuple{String, Tuple{Float64, Float64}}} where T","page":"API Reference","title":"Geodynamo.combine_time_series","text":"combine_time_series(output_dir::String, time_range::Tuple{Float64,Float64}; \n                   config::CombinerConfig = create_combiner_config(),\n                   precision::Type{T} = Float64) where T\n\nCombine multiple time points into a time series.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.combine_to_global!-Union{Tuple{FieldCombiner{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.combine_to_global!","text":"combine_to_global!(combiner::FieldCombiner{T}) where T\n\nCombine distributed field data into global field structures.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.combine_velocity_spectral!-Union{Tuple{T}, Tuple{FieldCombiner{T}, Dict}} where T","page":"API Reference","title":"Geodynamo.combine_velocity_spectral!","text":"combine_velocity_spectral!(combiner::FieldCombiner{T}, lm_mapping::Dict) where T\n\nCombine velocity spectral coefficients from all distributed files.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_all_gradients_spectral!-Union{Tuple{T}, Tuple{Geodynamo.AbstractScalarField{T}, RadialDomain}} where T","page":"API Reference","title":"Geodynamo.compute_all_gradients_spectral!","text":"compute_all_gradients_spectral!(field::AbstractScalarField{T}, domain::RadialDomain) where T\n\nCompute all gradient components (θ, φ, r) in spectral space. This is the main driver function that works for any scalar field.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_boundary_fluxes-Union{Tuple{T}, Tuple{Vector{T}, Any, RadialDomain}} where T","page":"API Reference","title":"Geodynamo.compute_boundary_fluxes","text":"compute_boundary_fluxes(profile::Vector{T}, dr_matrix, domain::RadialDomain) where T\n\nCompute flux (dT/dr) at both boundaries using the derivative matrix. Note: drmatrix should be a BandedMatrix{T} (defined in linearalgebra.jl)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_chebyshev_polynomial-Tuple{Int64, RadialDomain}","page":"API Reference","title":"Geodynamo.compute_chebyshev_polynomial","text":"compute_chebyshev_polynomial(n::Int, domain::RadialDomain)\n\nCompute Chebyshev polynomial T_n on the radial grid.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_global_diagnostics-Union{Tuple{FieldCombiner{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.compute_global_diagnostics","text":"compute_global_diagnostics(combiner::FieldCombiner{T}) where T\n\nCompute global diagnostics for the combined fields.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_global_diagnostics-Union{Tuple{SpectralToPhysicalConverter{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.compute_global_diagnostics","text":"compute_global_diagnostics(converter::SpectralToPhysicalConverter{T}) where T\n\nCompute global field diagnostics using MPI reductions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_influence_functions_flux-Tuple{RadialDomain}","page":"API Reference","title":"Geodynamo.compute_influence_functions_flux","text":"compute_influence_functions_flux(oc_domain::RadialDomain)\n\nCompute influence functions for flux BCs. These are solutions to the homogeneous equation with specific BCs.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_inner_tau_function-Tuple{RadialDomain}","page":"API Reference","title":"Geodynamo.compute_inner_tau_function","text":"compute_inner_tau_function(domain::RadialDomain)\n\nCompute tau function for inner boundary only (zero derivative at outer).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_magnetic_helicity-Union{Tuple{SHTnsMagneticFields{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.compute_magnetic_helicity","text":"compute_magnetic_helicity(mag_fields::SHTnsMagneticFields{T}) where T\n\nCompute magnetic helicity using enhanced spectral integration\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_nonlinear!-Union{Tuple{T}, Tuple{CPUParallelizer{T}, Any, Any, Any}} where T","page":"API Reference","title":"Geodynamo.compute_nonlinear!","text":"compute_nonlinear!(parallelizer, temp_field, vel_fields, domain)\n\nAdvanced CPU computation with SIMD, NUMA, and task-based parallelism.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_outer_tau_function-Tuple{RadialDomain}","page":"API Reference","title":"Geodynamo.compute_outer_tau_function","text":"compute_outer_tau_function(domain::RadialDomain)\n\nCompute tau function for outer boundary only (zero derivative at inner).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_phi1_function-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T","page":"API Reference","title":"Geodynamo.compute_phi1_function","text":"compute_phi1_function(A, expA)\n\nCompute φ1(A) = (exp(A) - I) / A efficiently with comprehensive error handling. Uses series expansion for small ||A|| to avoid numerical issues.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_phi2_function-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T","page":"API Reference","title":"Geodynamo.compute_phi2_function","text":"compute_phi2_function(A, expA)\n\nCompute φ2(A) = (exp(A) - I - A) / A² efficiently with comprehensive error handling. Uses series expansion for small ||A|| to avoid numerical issues.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_phi_gradient_spectral!-Union{Tuple{Geodynamo.AbstractScalarField{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.compute_phi_gradient_spectral!","text":"compute_phi_gradient_spectral!(field::AbstractScalarField{T}) where T\n\nCompute ∂field/∂φ using spherical harmonic properties (local operation). This is generic and works for any scalar field.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_radial_gradient_spectral!-Union{Tuple{T}, Tuple{Geodynamo.AbstractScalarField{T}, RadialDomain}} where T","page":"API Reference","title":"Geodynamo.compute_radial_gradient_spectral!","text":"compute_radial_gradient_spectral!(field::AbstractScalarField{T}, domain::RadialDomain) where T\n\nCompute ∂field/∂r using banded matrix derivative operator in spectral space (local operation). This uses the pre-computed derivative matrices from the field for optimal accuracy and efficiency.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_scalar_advection_local!-Union{Tuple{T}, Tuple{Geodynamo.AbstractScalarField{T}, Any}} where T","page":"API Reference","title":"Geodynamo.compute_scalar_advection_local!","text":"compute_scalar_advection_local!(field::AbstractScalarField{T}, vel_fields) where T\n\nCompute -u·∇field in physical space (completely local operation). This works for any scalar field.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_scalar_energy-Union{Tuple{T}, Tuple{Geodynamo.AbstractScalarField{T}, RadialDomain}} where T","page":"API Reference","title":"Geodynamo.compute_scalar_energy","text":"compute_scalar_energy(field::AbstractScalarField{T}, oc_domain::RadialDomain) where T\n\nCompute energy ∫ field² dV\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_scalar_rms-Union{Tuple{T}, Tuple{Geodynamo.AbstractScalarField{T}, RadialDomain}} where T","page":"API Reference","title":"Geodynamo.compute_scalar_rms","text":"compute_scalar_rms(field::AbstractScalarField{T}, oc_domain::RadialDomain) where T\n\nCompute RMS value of scalar field.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_spectral_energy_diagnostics!-Tuple{Dict{String, Float64}, String, AbstractArray, AbstractArray, FieldInfo}","page":"API Reference","title":"Geodynamo.compute_spectral_energy_diagnostics!","text":"compute_spectral_energy_diagnostics!(diagnostics, component, real_part, imag_part, field_info)\n\nCompute spectral energy distribution diagnostics using SHTns configuration\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_tau_coefficients_both-Union{Tuple{T}, Tuple{T, T, RadialDomain}} where T","page":"API Reference","title":"Geodynamo.compute_tau_coefficients_both","text":"compute_tau_coefficients_both(flux_error_inner::T, flux_error_outer::T, domain::RadialDomain) where T\n\nCompute tau polynomial coefficients for both boundaries. Uses highest two Chebyshev modes as tau functions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_tau_coefficients_inner-Union{Tuple{T}, Tuple{T, RadialDomain}} where T","page":"API Reference","title":"Geodynamo.compute_tau_coefficients_inner","text":"compute_tau_coefficients_inner(flux_error::T, domain::RadialDomain) where T\n\nCompute tau coefficient for inner boundary only. Uses a single tau function that doesn't affect outer boundary.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_tau_coefficients_outer-Union{Tuple{T}, Tuple{T, RadialDomain}} where T","page":"API Reference","title":"Geodynamo.compute_tau_coefficients_outer","text":"compute_tau_coefficients_outer(flux_error::T, domain::RadialDomain) where T\n\nCompute tau coefficient for outer boundary only. Uses a single tau function that doesn't affect inner boundary.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_theta_gradient_spectral!-Union{Tuple{Geodynamo.AbstractScalarField{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.compute_theta_gradient_spectral!","text":"compute_theta_gradient_spectral!(field::AbstractScalarField{T}) where T\n\nCompute ∂field/∂θ using spherical harmonic recurrence relations (local operation). This is generic and works for any scalar field.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.compute_theta_recurrence_coefficients-Union{Tuple{T}, Tuple{Type{T}, SHTnsKitConfig}} where T","page":"API Reference","title":"Geodynamo.compute_theta_recurrence_coefficients","text":"compute_theta_recurrence_coefficients(::Type{T}, config::SHTnsKitConfig) where T\n\nPre-compute recurrence coefficients for θ-derivatives. Store as [nlm, 2] matrix: [:, 1] for l-1 coupling, [:, 2] for l+1 coupling\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.convert_spectral_file-Union{Tuple{String}, Tuple{T}, Tuple{String, String}} where T","page":"API Reference","title":"Geodynamo.convert_spectral_file","text":"convert_spectral_file(input_filename::String, output_filename::String = \"\";\n                     precision::Type{T} = Float64, \n                     compute_diagnostics::Bool = true) where T\n\nMain function to convert a single spectral data file to physical space.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.convert_to_physical!-Union{Tuple{SpectralToPhysicalConverter{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.convert_to_physical!","text":"convert_to_physical!(converter::SpectralToPhysicalConverter{T}) where T\n\nConvert all loaded spectral data to physical space using SHTns transforms.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.create_boundary_slice-Tuple{Tuple, Int64, Symbol, Int64}","page":"API Reference","title":"Geodynamo.create_boundary_slice","text":"create_boundary_slice(size_arr::Tuple, dim::Int, side::Symbol, width::Int)\n\nCreate array slice for boundary data extraction.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.create_combiner_config-Tuple{}","page":"API Reference","title":"Geodynamo.create_combiner_config","text":"create_combiner_config(; kwargs...)\n\nCreate combiner configuration with keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.create_computation_pencils-Tuple{Any, Tuple{Int64, Int64, Int64}, Any}","page":"API Reference","title":"Geodynamo.create_computation_pencils","text":"create_computation_pencils(topology, dims, config)\n\nCreate specialized pencils for different stages of computation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.create_enhanced_field_variables!-Tuple{Any, FieldInfo, OutputConfig, Vector{String}}","page":"API Reference","title":"Geodynamo.create_enhanced_field_variables!","text":"create_enhanced_field_variables!(nc_file, field_info::FieldInfo, config::OutputConfig, \n                                available_fields::Vector{String})\n\nEnhanced field variable setup that leverages SHTns configuration\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.create_enhanced_output_config-Union{Tuple{SimulationState{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.create_enhanced_output_config","text":"create_enhanced_output_config(state)\n\nCreate output configuration with enhanced I/O settings.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.create_erk2_cache-Union{Tuple{T}, Tuple{Type{T}, SHTnsKitConfig, RadialDomain, Float64, Float64}} where T","page":"API Reference","title":"Geodynamo.create_erk2_cache","text":"create_erk2_cache(config, domain, diffusivity, dt; use_krylov=false, m=20, tol=1e-8)\n\nCreate ERK2 cache with precomputed matrix functions for all spherical harmonic modes.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.create_erk2_config-Tuple{}","page":"API Reference","title":"Geodynamo.create_erk2_config","text":"create_erk2_config(; lmax, mmax, nlat, nlon, optimize_for_erk2=true)\n\nCreate an SHTnsKit configuration for ERK2 timestepping.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.create_etd_cache-Union{Tuple{T}, Tuple{Type{T}, SHTnsKitConfig, RadialDomain, Float64, Float64}} where T","page":"API Reference","title":"Geodynamo.create_etd_cache","text":"create_etd_cache(config, domain, diffusivity, dt) -> ETDCache\n\nBuild per-l exponential cache for the linear operator Al = diffusivity*(d²/dr² + (2/r)d/dr − l(l+1)/r²). Computes exp(dt Al) and phi1(dt A_l) via dense methods. Single-rank recommended.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.create_field_combiner-Union{Tuple{T}, Tuple{String, Float64}} where T","page":"API Reference","title":"Geodynamo.create_field_combiner","text":"create_field_combiner(output_dir::String, time::Float64; \n                     precision::Type{T} = Float64) where T\n\nCreate a field combiner by reading configuration from distributed files.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.create_halo_slice-Tuple{Tuple, Int64, Symbol, Int64}","page":"API Reference","title":"Geodynamo.create_halo_slice","text":"create_halo_slice(size_arr::Tuple, dim::Int, side::Symbol, width::Int)\n\nCreate array slice for halo region insertion.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.create_memory_efficient_output_buffer-Tuple{Int64, DataType}","page":"API Reference","title":"Geodynamo.create_memory_efficient_output_buffer","text":"create_memory_efficient_output_buffer(data_size::Int, precision::DataType)\n\nCreate appropriately sized buffer for output operations\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.create_parameter_template-Tuple{String}","page":"API Reference","title":"Geodynamo.create_parameter_template","text":"create_parameter_template(filename::String)\n\nCreate a template parameter file for users to customize.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.create_pencil_array-Union{Tuple{T}, Tuple{Type{T}, PencilArrays.Pencils.Pencil}} where T","page":"API Reference","title":"Geodynamo.create_pencil_array","text":"create_pencil_array(::Type{T}, pencil::Pencil; init=:zero) where T\n\nCreate a PencilArray with specified initialization.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.create_pencil_decomposition_shtnskit","page":"API Reference","title":"Geodynamo.create_pencil_decomposition_shtnskit","text":"create_pencil_decomposition_shtnskit(nlat, nlon, nr, sht_config, comm, optimize)\n\nCreate PencilArrays decomposition optimized for theta-phi parallelization.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.create_pencil_fft_plans-Tuple{Any, Tuple{Int64, Int64, Int64}}","page":"API Reference","title":"Geodynamo.create_pencil_fft_plans","text":"create_pencil_fft_plans(pencils, dims)\n\nCreate PencilFFTs plans for efficient phi-direction transforms.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.create_pencil_topology-Tuple{Any}","page":"API Reference","title":"Geodynamo.create_pencil_topology","text":"create_pencil_topology(shtns_config; optimize=true)\n\nCreate enhanced pencil decomposition for SHTns grids. Supports both 1D and 2D decompositions with automatic optimization. Accepts an object with fields nlat, nlon, and nlm (e.g., SHTnsKitConfig).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.create_shtns_aware_output_config-Tuple{SHTnsKitConfig, NamedTuple}","page":"API Reference","title":"Geodynamo.create_shtns_aware_output_config","text":"create_shtns_aware_output_config(shtns_config::SHTnsKitConfig, pencils::NamedTuple; \n                                base_config::OutputConfig = default_config())\n\nCreate output configuration that integrates with SHTns configuration and pencil decomposition\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.create_shtnskit_config-Tuple{}","page":"API Reference","title":"Geodynamo.create_shtnskit_config","text":"create_shtnskit_config(; lmax::Int, mmax::Int=lmax, nlat::Int=lmax+2,\n                       nlon::Int=max(2*lmax+1, 4), optimize_decomp::Bool=true) -> SHTnsKitConfig\n\nCreate SHTnsKit configuration with MPI parallelization using PencilArrays. This creates proper integration with ../SHTnsKit.jl, PencilArrays, and PencilFFTs.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.create_shtnskit_transpose_plans-Tuple{Any}","page":"API Reference","title":"Geodynamo.create_shtnskit_transpose_plans","text":"create_shtnskit_transpose_plans(pencils)\n\nCreate transpose plans for efficient pencil reorientations.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.create_spectral_converter-Union{Tuple{String}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.create_spectral_converter","text":"create_spectral_converter(filename::String; precision::Type{T} = Float64) where T\n\nCreate a spectral to physical converter by reading configuration from a NetCDF file.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.create_transpose_plans-Tuple{Any}","page":"API Reference","title":"Geodynamo.create_transpose_plans","text":"create_transpose_plans(pencils)\n\nCreate enhanced transpose plans between pencil orientations. Includes caching and communication optimization.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.eab2_update!-Union{Tuple{T}, Tuple{SHTnsSpectralField{T}, SHTnsSpectralField{T}, SHTnsSpectralField{T}, Geodynamo.ETDCache{T}, SHTnsKitConfig, Float64}} where T","page":"API Reference","title":"Geodynamo.eab2_update!","text":"eab2_update!(u, nl, nl_prev, etd, config)\n\nApply EAB2 update per (l,m): u^{n+1} = E u^n + dtphi1(3/2 nl^n − 1/2 nl^{n−1}).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.eab2_update_krylov!-Union{Tuple{T}, Tuple{SHTnsSpectralField{T}, SHTnsSpectralField{T}, SHTnsSpectralField{T}, RadialDomain, Float64, SHTnsKitConfig, Float64}} where T","page":"API Reference","title":"Geodynamo.eab2_update_krylov!","text":"eab2_update_krylov!(u, nl, nl_prev, domain, diffusivity, config, dt; m=20, tol=1e-8)\n\nEAB2 update using Krylov exp/φ1 actions and banded LU for φ1.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.eab2_update_krylov_cached!-Union{Tuple{T}, Tuple{SHTnsSpectralField{T}, SHTnsSpectralField{T}, SHTnsSpectralField{T}, Dict{Int64, Tuple{BandedMatrix{T}, Geodynamo.BandedLU{T}}}, RadialDomain, Float64, SHTnsKitConfig, Float64}} where T","page":"API Reference","title":"Geodynamo.eab2_update_krylov_cached!","text":"eab2_update_krylov_cached!(u, nl, nl_prev, alu_map, domain, ν, config, dt; m=20, tol=1e-8)\n\nSame as eab2updatekrylov!, but reuses cached banded A and LU per l.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.enforce_composition_boundary_values!-Union{Tuple{SHTnsCompositionField{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.enforce_composition_boundary_values!","text":"enforce_composition_boundary_values!(field)\n\nAnchor spectral boundary modes to stored Dirichlet values when applicable.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.enforce_magnetic_boundary_values!-Union{Tuple{SHTnsMagneticFields{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.enforce_magnetic_boundary_values!","text":"enforce_magnetic_boundary_values!(fields)\n\nAnchor magnetic toroidal/poloidal spectral data to cached Dirichlet boundary values on the inner and outer radial surfaces.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.enforce_velocity_boundary_values!-Union{Tuple{SHTnsVelocityFields{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.enforce_velocity_boundary_values!","text":"enforce_velocity_boundary_values!(fields)\n\nAnchor toroidal and poloidal spectral coefficients to the currently cached Dirichlet boundary values on the inner and outer radial surfaces.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.erk2_stage_residual_stats-Union{Tuple{Geodynamo.ERK2FieldBuffers{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.erk2_stage_residual_stats","text":"erk2_stage_residual_stats(buffers) -> NamedTuple\n\nCompute diagnostic statistics for the difference between stage nonlinear terms and the base-step nonlinear terms.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.estimate_memory_usage-Tuple{Any, Int64, Type}","page":"API Reference","title":"Geodynamo.estimate_memory_usage","text":"estimate_memory_usage(pencils, field_count::Int, precision::Type)\n\nEstimate memory usage for given pencil configuration.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.estimate_memory_usage_shtnskit-Union{Tuple{T}, Tuple{Int64, Int64, Int64, Int64, Type{T}}} where T","page":"API Reference","title":"Geodynamo.estimate_memory_usage_shtnskit","text":"estimate_memory_usage_shtnskit(nlat, nlon, lmax, field_count, T)\n\nEstimate memory usage for SHTnsKit-based transforms with PencilArrays.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.evaluate_chebyshev_derivative-Union{Tuple{T}, Tuple{Int64, T, RadialDomain}} where T","page":"API Reference","title":"Geodynamo.evaluate_chebyshev_derivative","text":"evaluate_chebyshev_derivative(n::Int, r::T, domain::RadialDomain) where T\n\nEvaluate derivative of Chebyshev polynomial at a point.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.evaluate_tau_derivative_inner-Tuple{Vector, RadialDomain}","page":"API Reference","title":"Geodynamo.evaluate_tau_derivative_inner","text":"evaluate_tau_derivative_inner(tau::Vector, domain::RadialDomain)\n\nEvaluate tau function derivative at inner boundary.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.evaluate_tau_derivative_outer-Tuple{Vector, RadialDomain}","page":"API Reference","title":"Geodynamo.evaluate_tau_derivative_outer","text":"evaluate_tau_derivative_outer(tau::Vector, domain::RadialDomain)\n\nEvaluate tau function derivative at outer boundary.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.exchange_dimension_halos!-Tuple{Array, PencilArrays.Pencils.Pencil, Int64, Int64, Symbol, MPI.Comm}","page":"API Reference","title":"Geodynamo.exchange_dimension_halos!","text":"exchange_dimension_halos!(data::Array, pencil::Pencil, dim::Int, \n                          halo_width::Int, boundaries::Symbol, comm::MPI.Comm)\n\nPerform halo exchange along a specific dimension using MPI point-to-point communication.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.exp_action_krylov-Union{Tuple{T}, Tuple{Any, Vector{T}, Float64}} where T","page":"API Reference","title":"Geodynamo.exp_action_krylov","text":"exp_action_krylov(Aop!, v, dt; m=20, tol=1e-8) -> y ≈ exp(dt A) v\n\nSimple Arnoldi-based approximation of the exponential action.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.extract_coefficients_for_shtnskit!-Tuple{Matrix{ComplexF64}, Vararg{Any, 4}}","page":"API Reference","title":"Geodynamo.extract_coefficients_for_shtnskit!","text":"extract_coefficients_for_shtnskit!(coeffs_buffer, spec_real, spec_imag, r_local, config)\n\nExtract spectral coefficients in format expected by SHTnsKit using pre-allocated buffer.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.extract_local_radial_profile!-Union{Tuple{T}, Tuple{Vector{T}, AbstractArray{T, 3}, Int64, Int64, Any}} where T","page":"API Reference","title":"Geodynamo.extract_local_radial_profile!","text":"extract_local_radial_profile!(profile, data, local_lm, nr, r_range)\n\nIn-place version to avoid allocations; writes the local radial line into profile for the given local_lm using the provided r_range.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.extract_physical_slice_generic!-Union{Tuple{T}, Tuple{Matrix{T}, Any, Any, Any}} where T","page":"API Reference","title":"Geodynamo.extract_physical_slice_generic!","text":"extract_physical_slice_generic!(slice_buffer, phys_data, r_local, config)\n\nGeneric extraction for any pencil orientation using pre-allocated buffer.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.extract_physical_slice_phi_local!-Union{Tuple{T}, Tuple{Matrix{T}, Any, Any, Any}} where T","page":"API Reference","title":"Geodynamo.extract_physical_slice_phi_local!","text":"extract_physical_slice_phi_local!(slice_buffer, phys_data, r_local, config)\n\nExtract physical slice when in phi-local pencil using pre-allocated buffer.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.extract_spectral_subset-Union{Tuple{SHTnsSpectralField{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.extract_spectral_subset","text":"extract_spectral_subset(field::SHTnsSpectralField{T}; l_max::Int = 10) where T\n\nExtract a subset of spectral modes for analysis.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.extract_vector_component_generic!-Union{Tuple{T}, Tuple{Matrix{T}, Any, Any, Any}} where T","page":"API Reference","title":"Geodynamo.extract_vector_component_generic!","text":"extract_vector_component_generic!(component_buffer, v_data, r_local, config)\n\nGeneric extraction for vector components using pre-allocated buffer.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.find_distributed_files","page":"API Reference","title":"Geodynamo.find_distributed_files","text":"find_distributed_files(output_dir::String, time::Float64, filename_prefix::String = \"geodynamo\")\n\nFind all distributed files for a specific simulation time.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.find_package_root-Tuple{}","page":"API Reference","title":"Geodynamo.find_package_root","text":"find_package_root()\n\nFind the root directory of the Geodynamo.jl package.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.get_comm-Tuple{}","page":"API Reference","title":"Geodynamo.get_comm","text":"get_comm()\n\nGet MPI communicator, initializing MPI if needed. Provides thread-safe lazy initialization.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.get_dimension_neighbors-Tuple{PencilArrays.Pencils.Pencil, Int64, Symbol}","page":"API Reference","title":"Geodynamo.get_dimension_neighbors","text":"get_dimension_neighbors(pencil::Pencil, dim::Int, boundaries::Symbol) -> (Int, Int)\n\nGet left and right neighbor process ranks for a given dimension. Returns (leftneighbor, rightneighbor) where MPI.MPIPROCNULL indicates no neighbor.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.get_eab2_alu_cache!-Union{Tuple{T}, Tuple{Dict{Symbol, Any}, Symbol, Float64, Type{T}, RadialDomain}} where T","page":"API Reference","title":"Geodynamo.get_eab2_alu_cache!","text":"get_eab2_alu_cache!(caches, key, ν, T, domain) -> Dict{Int,Tuple{BandedMatrix{T},BandedLU{T}}}\n\nRetrieve or initialize a cache mapping l -> (Abanded, LU(Abanded)) for EAB2. Reinitializes if ν or nr changed.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.get_erk2_cache!-Union{Tuple{T}, Tuple{Dict{Symbol, Any}, Symbol, Float64, Type{T}, SHTnsKitConfig, RadialDomain, Float64}} where T","page":"API Reference","title":"Geodynamo.get_erk2_cache!","text":"get_erk2_cache!(caches, key, diffusivity, config, domain, dt; use_krylov=false)\n\nRetrieve or create ERK2 cache with automatic invalidation when parameters change.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.get_flux_value-Tuple{Int64, Int64, Geodynamo.AbstractScalarField}","page":"API Reference","title":"Geodynamo.get_flux_value","text":"get_flux_value(lm_idx::Int, boundary::Int, field::AbstractScalarField)\n\nGet prescribed flux value for given mode and boundary from scalar field. This is a generic version that works with any scalar field.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.get_nprocs-Tuple{}","page":"API Reference","title":"Geodynamo.get_nprocs","text":"get_nprocs()\n\nGet total number of MPI processes.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.get_parameters-Tuple{}","page":"API Reference","title":"Geodynamo.get_parameters","text":"get_parameters()\n\nGet the current global parameters. If not set, loads default parameters.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.get_pencil_orientation-Tuple{PencilArrays.Pencils.Pencil{3}}","page":"API Reference","title":"Geodynamo.get_pencil_orientation","text":"get_pencil_orientation(pencil::Pencil{3}) -> Symbol\n\nGet the orientation of a pencil (which dimensions are local).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.get_process_dimensions-Tuple{Any}","page":"API Reference","title":"Geodynamo.get_process_dimensions","text":"get_process_dimensions(topology) -> Tuple\n\nExtract process grid dimensions from topology.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.get_rank-Tuple{}","page":"API Reference","title":"Geodynamo.get_rank","text":"get_rank()\n\nGet MPI rank of current process.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.get_shtnskit_performance_stats-Tuple{}","page":"API Reference","title":"Geodynamo.get_shtnskit_performance_stats","text":"get_shtnskit_performance_stats()\n\nGet performance statistics for SHTnsKit transforms with PencilArrays.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.hybrid_compute_nonlinear!-Union{Tuple{T}, Tuple{HybridParallelizer{T}, Any, Any, Any}} where T","page":"API Reference","title":"Geodynamo.hybrid_compute_nonlinear!","text":"hybrid_compute_nonlinear!(parallelizer, temp_field, vel_fields, domain)\n\nCompute nonlinear terms using hybrid MPI+threading parallelism.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.index_to_lm_shtnskit-Tuple{Int64, Int64, Int64}","page":"API Reference","title":"Geodynamo.index_to_lm_shtnskit","text":"index_to_lm_shtnskit(idx, lmax, mmax) -> (l, m)\n\nConvert linear index to (l,m) for SHTnsKit compatibility.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.infer_pencils_from_transpose_name-Tuple{Symbol, Any}","page":"API Reference","title":"Geodynamo.infer_pencils_from_transpose_name","text":"infer_pencils_from_transpose_name(name::Symbol, plan) -> (src_pencil, dest_pencil)\n\nInfer source and destination pencils from transpose operation name and plan. For TransposeOperator, we need to extract pencil info from context since the  operator itself doesn't expose src/dest pencils directly.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.initialize_enhanced_simulation-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.initialize_enhanced_simulation","text":"initialize_enhanced_simulation(::Type{T}=Float64; kwargs...)\n\nInitialize simulation with all parallelization features enabled.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.initialize_parameters","page":"API Reference","title":"Geodynamo.initialize_parameters","text":"initialize_parameters(config_file::String = \"\")\n\nInitialize the global parameter system.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.initialize_simulation-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.initialize_simulation","text":"initialize_master_simulation(::Type{T}=Float64; kwargs...)\n\nInitialize simulation with comprehensive CPU parallelization.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.install_erk2_cache_bundle!-Tuple{Dict{Symbol, Any}, Dict{Symbol, <:Geodynamo.ERK2Cache}}","page":"API Reference","title":"Geodynamo.install_erk2_cache_bundle!","text":"install_erk2_cache_bundle!(target, bundle)\n\nCopy ERK2 caches from bundle into the target cache dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.list_available_times","page":"API Reference","title":"Geodynamo.list_available_times","text":"list_available_times(output_dir::String, filename_prefix::String = \"geodynamo\")\n\nList all available simulation times in the output directory.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.load_distributed_fields!-Union{Tuple{FieldCombiner{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.load_distributed_fields!","text":"load_distributed_fields!(combiner::FieldCombiner{T}) where T\n\nLoad field data from all distributed files into the combiner structure.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.load_erk2_cache_bundle!-Tuple{Dict{Symbol, Any}, AbstractString}","page":"API Reference","title":"Geodynamo.load_erk2_cache_bundle!","text":"load_erk2_cache_bundle!(target, path) -> metadata\n\nLoad caches from path and install them into target, returning metadata.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.load_erk2_cache_bundle-Tuple{AbstractString}","page":"API Reference","title":"Geodynamo.load_erk2_cache_bundle","text":"load_erk2_cache_bundle(path) -> (caches, metadata)\n\nLoad ERK2 caches and associated metadata from disk.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.load_parameters","page":"API Reference","title":"Geodynamo.load_parameters","text":"load_parameters(config_file::String = \"\")\n\nLoad parameters from a configuration file. If no file is specified, loads from the default config/default_params.jl file.\n\nArguments\n\nconfig_file::String: Path to parameter file (optional)\n\nReturns\n\nGeodynamoParameters: Loaded parameters\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.load_parameters_from_file-Tuple{String}","page":"API Reference","title":"Geodynamo.load_parameters_from_file","text":"load_parameters_from_file(config_file::String)\n\nLoad parameters from a Julia file containing parameter definitions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.load_physical_temperature!-Union{Tuple{T}, Tuple{SHTnsPhysicalField{T}, Any, String}} where T","page":"API Reference","title":"Geodynamo.load_physical_temperature!","text":"load_physical_temperature!(field::SHTnsPhysicalField{T}, nc_file, var_name::String) where T\n\nLoad physical space temperature data from NetCDF file.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.load_single_file!-Union{Tuple{T}, Tuple{FieldCombiner{T}, String}} where T","page":"API Reference","title":"Geodynamo.load_single_file!","text":"load_single_file!(combiner::FieldCombiner{T}, filename::String) where T\n\nLoad data from a single file (no combination needed).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.load_single_spectral_field!-Union{Tuple{T}, Tuple{SHTnsSpectralField{T}, Any, String, String}} where T","page":"API Reference","title":"Geodynamo.load_single_spectral_field!","text":"load_single_spectral_field!(field::SHTnsSpectralField{T}, nc_file, \n                           real_var::String, imag_var::String) where T\n\nLoad a single spectral field from NetCDF file.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.load_spectral_coefficients!-Union{Tuple{T}, Tuple{SHTnsSpectralField{T}, Any, String, String, Vector{Int64}, Vector{Int64}, Vector{Float64}}} where T","page":"API Reference","title":"Geodynamo.load_spectral_coefficients!","text":"load_spectral_coefficients!(field::SHTnsSpectralField{T}, nc_file, \n                            real_var_name::String, imag_var_name::String,\n                            l_values::Vector{Int}, m_values::Vector{Int}, \n                            r_spectral::Vector{Float64}) where T\n\nLoad spectral coefficients from NetCDF file into a spectral field structure.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.load_spectral_data!-Union{Tuple{T}, Tuple{SpectralToPhysicalConverter{T}, String}} where T","page":"API Reference","title":"Geodynamo.load_spectral_data!","text":"load_spectral_data!(converter::SpectralToPhysicalConverter{T}, filename::String) where T\n\nLoad spectral field data from NetCDF file into Geodynamo field structures.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.main_batch_convert-Tuple{String}","page":"API Reference","title":"Geodynamo.main_batch_convert","text":"main_batch_convert(input_dir::String; kwargs...)\n\nMain entry point for batch conversion of files.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.main_combine_time-Tuple{String, Float64}","page":"API Reference","title":"Geodynamo.main_combine_time","text":"main_combine_time(output_dir::String, time::Float64; kwargs...)\n\nMain entry point for combining distributed files for a single time.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.main_combine_time_series-Tuple{String, Tuple{Float64, Float64}}","page":"API Reference","title":"Geodynamo.main_combine_time_series","text":"main_combine_time_series(output_dir::String, time_range::Tuple{Float64,Float64}; kwargs...)\n\nMain entry point for combining time series.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.main_convert_file-Tuple{String}","page":"API Reference","title":"Geodynamo.main_convert_file","text":"main_convert_file(filename::String; kwargs...)\n\nMain entry point for converting a single file.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.map_spectral_coefficients!-NTuple{11, Any}","page":"API Reference","title":"Geodynamo.map_spectral_coefficients!","text":"map_spectral_coefficients!(global_tor_real, global_tor_imag, global_pol_real, global_pol_imag,\n                          local_tor_real, local_tor_imag, local_pol_real, local_pol_imag,\n                          local_l, local_m, lm_mapping)\n\nMap local spectral coefficients to global arrays using (l,m) index mapping.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.maybe_log_erk2_stage_residual!-Tuple{Symbol, Geodynamo.ERK2FieldBuffers, Int64}","page":"API Reference","title":"Geodynamo.maybe_log_erk2_stage_residual!","text":"maybe_log_erk2_stage_residual!(label, buffers, step)\n\nEmit a diagnostic log entry when ERK2 diagnostics are enabled.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.modify_for_flux_inner!-NTuple{7, Any}","page":"API Reference","title":"Geodynamo.modify_for_flux_inner!","text":"modify_for_flux_inner!(spec_real, spec_imag, local_lm, prescribed_flux,\n                      dr_matrix, domain, r_range)\n\nModify coefficients near inner boundary to approximate flux condition. Uses low-order extrapolation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.modify_for_flux_outer!-NTuple{7, Any}","page":"API Reference","title":"Geodynamo.modify_for_flux_outer!","text":"modify_for_flux_outer!(spec_real, spec_imag, local_lm, prescribed_flux,\n                      dr_matrix, domain, r_range)\n\nModify coefficients near outer boundary to approximate flux condition. Uses low-order extrapolation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.normalize_influence_function!-Union{Tuple{T}, Tuple{Vector{T}, RadialDomain, Int64}} where T","page":"API Reference","title":"Geodynamo.normalize_influence_function!","text":"normalize_influence_function!(G::Vector{T}, domain::RadialDomain, which_boundary::Int) where T\n\nNormalize influence function to have unit flux at the specified boundary.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.optimize_communication_order-Tuple{Dict}","page":"API Reference","title":"Geodynamo.optimize_communication_order","text":"optimize_communication_order(plans::Dict)\n\nDetermine optimal order for transpose operations to minimize communication.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.optimize_erk2_transforms!-Tuple{SHTnsKitConfig}","page":"API Reference","title":"Geodynamo.optimize_erk2_transforms!","text":"optimize_erk2_transforms!(config::SHTnsKitConfig)\n\nOptimize SHTnsKit transforms for ERK2 timestepping with PencilFFTs. This function pre-warms transform plans and optimizes memory layout.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.optimize_fft_performance!-Tuple{SHTnsKitConfig}","page":"API Reference","title":"Geodynamo.optimize_fft_performance!","text":"optimize_fft_performance!(config::SHTnsKitConfig)\n\nOptimize PencilFFTs performance by warming up plans and checking efficiency.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.optimize_field_data_layout!-Tuple{Dict, FieldInfo}","page":"API Reference","title":"Geodynamo.optimize_field_data_layout!","text":"optimize_field_data_layout!(field_data::Dict, field_info::FieldInfo)\n\nOptimize data layout for output based on pencil decomposition\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.optimize_magnetic_memory_layout!-Union{Tuple{SHTnsMagneticFields{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.optimize_magnetic_memory_layout!","text":"optimize_magnetic_memory_layout!(mag_fields::SHTnsMagneticFields{T}) where T\n\nOptimize memory layout for better cache performance using pencil topology\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.optimize_process_topology-Tuple{Int64, Tuple{Int64, Int64, Int64}}","page":"API Reference","title":"Geodynamo.optimize_process_topology","text":"optimize_process_topology(nprocs::Int, dims::Tuple{Int,Int,Int})\n\nFind optimal 2D process grid for given number of processes and problem dimensions. Minimizes communication volume.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.optimize_process_topology_shtnskit-Tuple{Int64, Int64, Int64}","page":"API Reference","title":"Geodynamo.optimize_process_topology_shtnskit","text":"optimize_process_topology_shtnskit(nprocs, nlat, nlon)\n\nOptimize MPI process topology for theta-phi parallelization.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.optimize_velocity_memory_layout!-Union{Tuple{SHTnsVelocityFields{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.optimize_velocity_memory_layout!","text":"optimize_velocity_memory_layout!(fields::SHTnsVelocityFields{T}) where T\n\nOptimize memory layout for better cache performance using pencil topology\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.perform_analysis_direct!-Union{Tuple{T}, Tuple{SHTnsPhysicalField{T}, SHTnsSpectralField{T}, Any}} where T","page":"API Reference","title":"Geodynamo.perform_analysis_direct!","text":"perform_analysis_direct!(phys, spec, config)\n\nDirect analysis without transpose (fallback).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.perform_analysis_from_phi_pencil!-Union{Tuple{T}, Tuple{PencilArrays.PencilArray{T, 3, A} where A<:AbstractArray{T, 3}, SHTnsSpectralField{T}, Any}} where T","page":"API Reference","title":"Geodynamo.perform_analysis_from_phi_pencil!","text":"perform_analysis_from_phi_pencil!(phys_phi, spec, config)\n\nPerform analysis from phi-pencil data.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.perform_analysis_phi_local!-Union{Tuple{T}, Tuple{SHTnsPhysicalField{T}, SHTnsSpectralField{T}, Any}} where T","page":"API Reference","title":"Geodynamo.perform_analysis_phi_local!","text":"perform_analysis_phi_local!(phys, spec, config)\n\nPerform analysis when physical field is in phi-pencil (phi is local).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.perform_analysis_with_transpose!-Union{Tuple{T}, Tuple{SHTnsPhysicalField{T}, SHTnsSpectralField{T}, Any}} where T","page":"API Reference","title":"Geodynamo.perform_analysis_with_transpose!","text":"perform_analysis_with_transpose!(phys, spec, config)\n\nPerform analysis with transpose to phi-pencil.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.perform_synthesis_direct!-Union{Tuple{T}, Tuple{SHTnsSpectralField{T}, SHTnsPhysicalField{T}, Any}} where T","page":"API Reference","title":"Geodynamo.perform_synthesis_direct!","text":"perform_synthesis_direct!(spec, phys, config)\n\nDirect synthesis without transpose (fallback method).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.perform_synthesis_phi_local!-Union{Tuple{T}, Tuple{SHTnsSpectralField{T}, SHTnsPhysicalField{T}, Any}} where T","page":"API Reference","title":"Geodynamo.perform_synthesis_phi_local!","text":"perform_synthesis_phi_local!(spec, phys, config)\n\nPerform synthesis when physical field is already in phi-pencil (phi is local).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.perform_synthesis_to_phi_pencil!-Union{Tuple{T}, Tuple{SHTnsSpectralField{T}, PencilArrays.PencilArray{T, 3, A} where A<:AbstractArray{T, 3}, Any}} where T","page":"API Reference","title":"Geodynamo.perform_synthesis_to_phi_pencil!","text":"perform_synthesis_to_phi_pencil!(spec, phys_phi, config)\n\nPerform synthesis directly to phi-pencil array.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.perform_synthesis_with_transpose!-Union{Tuple{T}, Tuple{SHTnsSpectralField{T}, SHTnsPhysicalField{T}, Any}} where T","page":"API Reference","title":"Geodynamo.perform_synthesis_with_transpose!","text":"perform_synthesis_with_transpose!(spec, phys, config)\n\nPerform synthesis with transpose to phi-pencil for optimal FFT performance.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.phi1_action_krylov-Union{Tuple{T}, Tuple{Any, Geodynamo.BandedLU{T}, Vector{T}, Float64}} where T","page":"API Reference","title":"Geodynamo.phi1_action_krylov","text":"phi1_action_krylov(BA, LU_A, v, dt; m=20, tol=1e-8) -> y ≈ φ1(dt A) v\n\nCompute φ1(dt A) v = A^{-1}[(exp(dt A) − I) v]/dt using Krylov exp(action) and banded solve.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.print_pencil_axes-Tuple{Any}","page":"API Reference","title":"Geodynamo.print_pencil_axes","text":"print_pencil_axes(pencils)\n\nPrint the axes_in tuple for each pencil, showing the local index ranges for all three axes. This helps verify which axes are distributed (those with nontrivial subranges across ranks) and which axis is contiguous locally.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.print_pencil_info-Tuple{Any}","page":"API Reference","title":"Geodynamo.print_pencil_info","text":"print_pencil_info(pencils)\n\nPrint detailed information about pencil decomposition.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.print_shtnskit_config_summary-NTuple{7, Any}","page":"API Reference","title":"Geodynamo.print_shtnskit_config_summary","text":"print_shtnskit_config_summary(nlat, nlon, lmax, mmax, nlm, nprocs, memory_estimate)\n\nPrint configuration summary for SHTnsKit setup.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.print_transpose_statistics-Tuple{}","page":"API Reference","title":"Geodynamo.print_transpose_statistics","text":"print_transpose_statistics()\n\nPrint accumulated transpose timing statistics.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.read_distributed_metadata-Tuple{String}","page":"API Reference","title":"Geodynamo.read_distributed_metadata","text":"read_distributed_metadata(filename::String)\n\nRead metadata from a distributed NetCDF file to determine global configuration.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.read_file_metadata-Tuple{String}","page":"API Reference","title":"Geodynamo.read_file_metadata","text":"read_file_metadata(filename::String)\n\nRead metadata from NetCDF file to determine grid configuration.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.run_enhanced_simulation!-Union{Tuple{SimulationState{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.run_enhanced_simulation!","text":"run_enhanced_simulation!(state::SimulationState{T})\n\nRun geodynamo simulation with all parallelization optimizations.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.run_simulation!-Union{Tuple{SimulationState{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.run_simulation!","text":"run_master_simulation!(state::SimulationState{T})\n\nRun geodynamo simulation with maximum CPU parallelization optimizations.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.save_combined_fields-Union{Tuple{T}, Tuple{FieldCombiner{T}, String}} where T","page":"API Reference","title":"Geodynamo.save_combined_fields","text":"save_combined_fields(combiner::FieldCombiner{T}, output_filename::String; \n                    config::CombinerConfig = create_combiner_config()) where T\n\nSave combined fields to NetCDF file using Geodynamo I/O system.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.save_combined_time_series-Union{Tuple{T}, Tuple{Array{FieldCombiner{T}, 1}, String, String}} where T","page":"API Reference","title":"Geodynamo.save_combined_time_series","text":"save_combined_time_series(combiners::Vector{FieldCombiner{T}}, output_dir::String, \n                         filename_prefix::String; \n                         config::CombinerConfig = create_combiner_config()) where T\n\nSave combined time series to a single NetCDF file.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.save_erk2_cache_bundle-Tuple{AbstractString, Dict{Symbol, <:Geodynamo.ERK2Cache}}","page":"API Reference","title":"Geodynamo.save_erk2_cache_bundle","text":"save_erk2_cache_bundle(path, caches; metadata=Dict())\n\nPersist a dictionary of ERK2 caches to disk along with optional metadata.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.save_parameters-Tuple{GeodynamoParameters, String}","page":"API Reference","title":"Geodynamo.save_parameters","text":"save_parameters(params::GeodynamoParameters, filename::String)\n\nSave parameters to a Julia file.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.save_physical_fields-Union{Tuple{T}, Tuple{SpectralToPhysicalConverter{T}, String}} where T","page":"API Reference","title":"Geodynamo.save_physical_fields","text":"save_physical_fields(converter::SpectralToPhysicalConverter{T}, output_filename::String) where T\n\nSave converted physical space fields to NetCDF file using parallel I/O.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.set_parameters!-Tuple{GeodynamoParameters}","page":"API Reference","title":"Geodynamo.set_parameters!","text":"set_parameters!(params::GeodynamoParameters)\n\nSet the global parameters.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.set_velocity_workspace!-Tuple{Any}","page":"API Reference","title":"Geodynamo.set_velocity_workspace!","text":"set_velocity_workspace!(ws)\n\nRegister a global VelocityWorkspace to be used by velocity kernels when available. Pass nothing to disable and fall back to internal buffers.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.setup_shtns_metadata!-Tuple{Any, SHTnsKitConfig, NamedTuple}","page":"API Reference","title":"Geodynamo.setup_shtns_metadata!","text":"setup_shtns_metadata!(nc_file, shtns_config::SHTnsKitConfig, pencils::NamedTuple)\n\nAdd SHTns-specific metadata to NetCDF file\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.shtnskit_physical_to_spectral!-Union{Tuple{T}, Tuple{SHTnsPhysicalField{T}, SHTnsSpectralField{T}}} where T","page":"API Reference","title":"Geodynamo.shtnskit_physical_to_spectral!","text":"shtnskit_physical_to_spectral!(phys::SHTnsPhysicalField{T}, \n                              spec::SHTnsSpectralField{T}) where T\n\nTransform from physical to spectral space using SHTnsKit with PencilArrays.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.shtnskit_spectral_to_physical!-Union{Tuple{T}, Tuple{SHTnsSpectralField{T}, SHTnsPhysicalField{T}}} where T","page":"API Reference","title":"Geodynamo.shtnskit_spectral_to_physical!","text":"shtnskit_spectral_to_physical!(spec::SHTnsSpectralField{T}, \n                              phys::SHTnsPhysicalField{T}) where T\n\nTransform from spectral to physical space using SHTnsKit with PencilArrays/PencilFFTs.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.shtnskit_vector_analysis!-Union{Tuple{T}, Tuple{SHTnsVectorField{T}, SHTnsSpectralField{T}, SHTnsSpectralField{T}}} where T","page":"API Reference","title":"Geodynamo.shtnskit_vector_analysis!","text":"shtnskit_vector_analysis!(vec_phys::SHTnsVectorField{T},\n                         tor_spec::SHTnsSpectralField{T}, \n                         pol_spec::SHTnsSpectralField{T}) where T\n\nVector analysis using SHTnsKit with PencilArrays.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.shtnskit_vector_synthesis!-Union{Tuple{T}, Tuple{SHTnsSpectralField{T}, SHTnsSpectralField{T}, SHTnsVectorField{T}}} where T","page":"API Reference","title":"Geodynamo.shtnskit_vector_synthesis!","text":"shtnskit_vector_synthesis!(tor_spec::SHTnsSpectralField{T}, \n                          pol_spec::SHTnsSpectralField{T},\n                          vec_phys::SHTnsVectorField{T}) where T\n\nVector synthesis using SHTnsKit spheroidal-toroidal decomposition with PencilArrays.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.store_coefficients_from_shtnskit!-NTuple{5, Any}","page":"API Reference","title":"Geodynamo.store_coefficients_from_shtnskit!","text":"store_coefficients_from_shtnskit!(spec_real, spec_imag, coeffs_matrix, r_local, config)\n\nStore coefficients from SHTnsKit format back to spectral field.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.store_physical_slice_generic!-NTuple{4, Any}","page":"API Reference","title":"Geodynamo.store_physical_slice_generic!","text":"store_physical_slice_generic!(phys_data, phys_slice, r_local, config)\n\nGeneric storage for any pencil orientation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.store_physical_slice_phi_local!-NTuple{4, Any}","page":"API Reference","title":"Geodynamo.store_physical_slice_phi_local!","text":"store_physical_slice_phi_local!(phys_data, phys_slice, r_local, config)\n\nStore physical slice when in phi-local pencil.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.store_vector_components_generic!-NTuple{6, Any}","page":"API Reference","title":"Geodynamo.store_vector_components_generic!","text":"store_vector_components_generic!(v_theta, v_phi, vt_field, vp_field, r_local, config)\n\nStore vector components for any pencil orientation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.synchronize_halos!-Tuple{PencilArrays.PencilArray}","page":"API Reference","title":"Geodynamo.synchronize_halos!","text":"synchronize_halos!(arr::PencilArray; halo_width::Int=1, boundaries::Symbol=:all)\n\nSynchronize ghost/halo regions for parallel finite difference computations.\n\nParameters\n\narr: PencilArray to synchronize\nhalo_width: Width of halo region (number of ghost cells), default 1\nboundaries: Boundary handling (:all, :periodic, :nonperiodic), default :all\n\nNotes\n\nThis function implements MPI point-to-point communication to exchange boundary data between neighboring processes in each decomposed dimension. It's essential for  maintaining accuracy in finite difference stencil operations near subdomain boundaries.\n\nFor spectral methods, explicit halo exchange may not be needed as the global nature of spectral transforms handles boundary coupling through transpose operations.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.synchronize_pencil_data!-Union{Tuple{Union{SHTnsPhysicalField{T}, SHTnsSpectralField{T}}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.synchronize_pencil_data!","text":"synchronize_pencil_data!(field)\n\nSynchronize PencilArray data across MPI processes to ensure consistency.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.synchronize_pencil_transforms!-Union{Tuple{SHTnsSpectralField{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.synchronize_pencil_transforms!","text":"synchronize_pencil_transforms!(field::SHTnsSpectralField{T}) where T\n\nEnsure all pending PencilFFTs operations are completed and data is consistent across processes.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.test_halo_exchange-Union{Tuple{PencilArrays.Pencils.Pencil}, Tuple{T}, Tuple{PencilArrays.Pencils.Pencil, Type{T}}} where T","page":"API Reference","title":"Geodynamo.test_halo_exchange","text":"test_halo_exchange(pencil::Pencil, ::Type{T}=Float64; halo_width::Int=1, verbose::Bool=true) where T\n\nTest halo exchange functionality by creating a test array with rank-based values. Returns true if halo exchange is working correctly.\n\nExample\n\npencils = create_pencil_topology(shtns_config)\ntest_halo_exchange(pencils.θ, Float64; halo_width=1, verbose=true)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.transform_field_and_gradients_to_physical!-Union{Tuple{Geodynamo.AbstractScalarField{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.transform_field_and_gradients_to_physical!","text":"transform_field_and_gradients_to_physical!(field::AbstractScalarField{T}) where T\n\nTransform scalar field and all gradient components to physical space in a single batched operation to minimize communication.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.transpose_with_timer!","page":"API Reference","title":"Geodynamo.transpose_with_timer!","text":"transpose_with_timer!(dest, src, plan, label=\"\")\n\nPerform transpose with optional timing and statistics.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.update_derived_parameters!-Tuple{GeodynamoParameters}","page":"API Reference","title":"Geodynamo.update_derived_parameters!","text":"update_derived_parameters!(params::GeodynamoParameters)\n\nUpdate derived parameters based on primary parameters.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.update_global_parameters!-Tuple{}","page":"API Reference","title":"Geodynamo.update_global_parameters!","text":"update_global_parameters!()\n\nUpdate all global parameter variables with values from the current parameter struct.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.validate_magnetic_configuration-Union{Tuple{T}, Tuple{SHTnsMagneticFields{T}, SHTnsKitConfig}} where T","page":"API Reference","title":"Geodynamo.validate_magnetic_configuration","text":"validate_magnetic_configuration(mag_fields::SHTnsMagneticFields{T}, config::SHTnsKitConfig) where T\n\nValidate magnetic field configuration consistency with SHTns setup\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.validate_mpi_consistency!-Union{Tuple{SHTnsSpectralField{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.validate_mpi_consistency!","text":"validate_mpi_consistency!(field::SHTnsSpectralField{T}) where T\n\nCheck that spectral field data is consistent across MPI processes after time stepping.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.validate_output_compatibility-Tuple{FieldInfo, SHTnsKitConfig}","page":"API Reference","title":"Geodynamo.validate_output_compatibility","text":"validate_output_compatibility(field_info::FieldInfo, shtns_config::SHTnsKitConfig)\n\nValidate that output field information is compatible with SHTns configuration\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.validate_pencil_decomposition-Tuple{SHTnsKitConfig}","page":"API Reference","title":"Geodynamo.validate_pencil_decomposition","text":"validate_pencil_decomposition(config::SHTnsKitConfig)\n\nValidate that pencil decomposition is optimal for the problem size and MPI configuration.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.validate_velocity_configuration-Union{Tuple{T}, Tuple{SHTnsVelocityFields{T}, SHTnsKitConfig}} where T","page":"API Reference","title":"Geodynamo.validate_velocity_configuration","text":"validate_velocity_configuration(fields::SHTnsVelocityFields{T}, config::SHTnsKitConfig) where T\n\nValidate velocity field configuration consistency with SHTns setup\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.write_enhanced_coordinates!-Tuple{Any, FieldInfo, OutputConfig}","page":"API Reference","title":"Geodynamo.write_enhanced_coordinates!","text":"write_enhanced_coordinates!(nc_file, field_info::FieldInfo, config::OutputConfig)\n\nWrite coordinates with enhanced precision and metadata from SHTns config\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.write_grid_file!-Tuple{OutputConfig, FieldInfo, Union{Nothing, SHTnsKitConfig}, Dict{String, Any}}","page":"API Reference","title":"Geodynamo.write_grid_file!","text":"write_grid_file!(config::OutputConfig, field_info::FieldInfo,\n                shtns_config::Union{SHTnsKitConfig,Nothing},\n                metadata::Dict{String,Any})\n\nWrite a separate grid file containing all coordinate and grid information. This is written only once by rank 0 at the start of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.write_single_spectral_component!-Tuple{Any, String, Dict, OutputConfig}","page":"API Reference","title":"Geodynamo.write_single_spectral_component!","text":"write_single_spectral_component!(nc_file, component, field_data, config)\n\nWrite a single spectral component with enhanced memory handling\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.write_spectral_data_parallel!-Tuple{Any, String, String, AbstractArray, AbstractArray, FieldInfo}","page":"API Reference","title":"Geodynamo.write_spectral_data_parallel!","text":"write_spectral_data_parallel!(nc_file, real_name, imag_name, real_data, imag_data, field_info)\n\nWrite spectral data using parallel I/O strategies based on pencil decomposition\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.zero_scalar_work_arrays!-Union{Tuple{Geodynamo.AbstractScalarField{T}}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.zero_scalar_work_arrays!","text":"zero_scalar_work_arrays!(field::AbstractScalarField{T}) where T\n\nEfficiently zero all work arrays for a scalar field.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Boundary-Conditions","page":"API Reference","title":"Boundary Conditions","text":"","category":"section"},{"location":"api.html#Geodynamo.BoundaryConditions.AbstractBoundaryCondition","page":"API Reference","title":"Geodynamo.BoundaryConditions.AbstractBoundaryCondition","text":"AbstractBoundaryCondition{T}\n\nAbstract base type for all boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.BoundaryConditions.BoundaryCache","page":"API Reference","title":"Geodynamo.BoundaryConditions.BoundaryCache","text":"BoundaryCache{T}\n\nCache structure for storing processed boundary data.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.BoundaryConditions.BoundaryConditionSet","page":"API Reference","title":"Geodynamo.BoundaryConditions.BoundaryConditionSet","text":"BoundaryConditionSet{T}\n\nComplete set of boundary conditions for inner and outer boundaries.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.BoundaryConditions.BoundaryData","page":"API Reference","title":"Geodynamo.BoundaryConditions.BoundaryData","text":"BoundaryData{T}\n\nCommon data structure for boundary condition data from any source.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.BoundaryConditions.BoundaryLocation","page":"API Reference","title":"Geodynamo.BoundaryConditions.BoundaryLocation","text":"BoundaryLocation\n\nEnumeration for boundary locations.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.BoundaryConditions.BoundaryType","page":"API Reference","title":"Geodynamo.BoundaryConditions.BoundaryType","text":"BoundaryType\n\nEnumeration for boundary condition types.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.BoundaryConditions.FieldType","page":"API Reference","title":"Geodynamo.BoundaryConditions.FieldType","text":"FieldType\n\nEnumeration for different physical field types.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Geodynamo.BoundaryConditions.add_noise_to_boundary","page":"API Reference","title":"Geodynamo.BoundaryConditions.add_noise_to_boundary","text":"add_noise_to_boundary(boundary_data::BoundaryData, noise_amplitude::Real, \n                     noise_type::Symbol=:gaussian)\n\nAdd noise to existing boundary data.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.BoundaryConditions.apply_boundary_conditions!-Tuple{Any, Geodynamo.BoundaryConditions.FieldType, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.apply_boundary_conditions!","text":"apply_boundary_conditions!(field, field_type::FieldType, solver_state)\n\nApply boundary conditions during solver operations.\n\nThis function integrates boundary conditions with the timestepping and solving process.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.apply_boundary_conditions_to_rhs!-Tuple{Any, Any, Geodynamo.BoundaryConditions.FieldType}","page":"API Reference","title":"Geodynamo.BoundaryConditions.apply_boundary_conditions_to_rhs!","text":"apply_boundary_conditions_to_rhs!(rhs, state, field_type::FieldType)\n\nApply boundary conditions to right-hand side during timestepping.\n\nThis function modifies the RHS vector to enforce boundary conditions during implicit and explicit timestepping methods.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.apply_composition_bc_to_rhs!-Tuple{Any, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.apply_composition_bc_to_rhs!","text":"apply_composition_bc_to_rhs!(rhs, comp_field)\n\nApply composition boundary conditions to RHS vector.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.apply_composition_boundary_conditions!","page":"API Reference","title":"Geodynamo.BoundaryConditions.apply_composition_boundary_conditions!","text":"apply_composition_boundary_conditions!(comp_field, time_index::Int=1)\n\nApply composition boundary conditions to the field.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.BoundaryConditions.apply_gaussian_smoothing!-Tuple{AbstractMatrix, Vector, Vector, Real}","page":"API Reference","title":"Geodynamo.BoundaryConditions.apply_gaussian_smoothing!","text":"apply_gaussian_smoothing!(data::AbstractMatrix, theta::Vector, phi::Vector, radius::Real)\n\nApply Gaussian smoothing kernel to 2D data array.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.apply_magnetic_bc_to_rhs!-Tuple{Any, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.apply_magnetic_bc_to_rhs!","text":"apply_magnetic_bc_to_rhs!(rhs, magnetic_field)\n\nApply magnetic field boundary conditions to RHS vector.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.apply_magnetic_boundary_conditions!","page":"API Reference","title":"Geodynamo.BoundaryConditions.apply_magnetic_boundary_conditions!","text":"apply_magnetic_boundary_conditions!(magnetic_field, time_index::Int=1)\n\nApply magnetic field boundary conditions to the field.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.BoundaryConditions.apply_temperature_bc_to_rhs!-Tuple{Any, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.apply_temperature_bc_to_rhs!","text":"apply_temperature_bc_to_rhs!(rhs, temp_field)\n\nApply temperature boundary conditions to RHS vector.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.apply_temperature_boundary_conditions!","page":"API Reference","title":"Geodynamo.BoundaryConditions.apply_temperature_boundary_conditions!","text":"apply_temperature_boundary_conditions!(temp_field, time_index::Int=1)\n\nApply temperature boundary conditions to the field.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.BoundaryConditions.apply_velocity_bc_to_rhs!-Tuple{Any, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.apply_velocity_bc_to_rhs!","text":"apply_velocity_bc_to_rhs!(rhs, velocity_field)\n\nApply velocity boundary conditions to RHS vector.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.apply_velocity_boundary_conditions!","page":"API Reference","title":"Geodynamo.BoundaryConditions.apply_velocity_boundary_conditions!","text":"apply_velocity_boundary_conditions!(velocity_field, time_index::Int=1)\n\nApply velocity boundary conditions to the field.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.BoundaryConditions.bilinear_interpolate-Union{Tuple{T}, Tuple{Matrix{T}, Tuple{Int64, Int64}, Tuple{Int64, Int64}, Tuple{T, T}, Tuple{T, T}}} where T","page":"API Reference","title":"Geodynamo.BoundaryConditions.bilinear_interpolate","text":"bilinear_interpolate(data::Matrix{T}, theta_idx::Tuple{Int, Int}, phi_idx::Tuple{Int, Int},\n                    theta_weights::Tuple{T, T}, phi_weights::Tuple{T, T}) where T\n\nPerform bilinear interpolation on a 2D data array. Handles periodic boundary conditions in phi direction.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.cache_boundary_data!-Union{Tuple{T}, Tuple{Geodynamo.BoundaryConditions.BoundaryCache{T}, String, Array{T}}} where T","page":"API Reference","title":"Geodynamo.BoundaryConditions.cache_boundary_data!","text":"cache_boundary_data!(cache::BoundaryCache{T}, key::String, data::Array{T}) where T\n\nCache processed boundary data.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.calculate_potential_field_boundary-Tuple{Dict, Vector, Vector, Int64}","page":"API Reference","title":"Geodynamo.BoundaryConditions.calculate_potential_field_boundary","text":"calculate_potential_field_boundary(coeffs::Dict, theta::Vector, phi::Vector, lmax::Int)\n\nCalculate magnetic field from spherical harmonic coefficients of the potential.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.check_interpolation_bounds-Union{Tuple{T}, Tuple{Geodynamo.BoundaryConditions.BoundaryData, Vector{T}, Vector{T}}} where T","page":"API Reference","title":"Geodynamo.BoundaryConditions.check_interpolation_bounds","text":"check_interpolation_bounds(boundary_data::BoundaryData, target_theta::Vector{T}, \n                          target_phi::Vector{T}) where T\n\nCheck if target grid is within the bounds of the source grid and warn if extrapolation is needed.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.clear_boundary_cache!-Tuple{Geodynamo.BoundaryConditions.BoundaryCache}","page":"API Reference","title":"Geodynamo.BoundaryConditions.clear_boundary_cache!","text":"clear_boundary_cache!(cache::BoundaryCache)\n\nClear all cached boundary data.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.combine_programmatic_patterns-Tuple{Vector{Tuple{Symbol, Real}}, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.combine_programmatic_patterns","text":"combine_programmatic_patterns(patterns::Vector{Tuple{Symbol, Real}}, config; \n                             parameters::Vector{Dict}=Dict[], description::String=\"\")\n\nCombine multiple programmatic patterns with different amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.compute_boundary_condition_residual-Tuple{Any, Geodynamo.BoundaryConditions.FieldType}","page":"API Reference","title":"Geodynamo.BoundaryConditions.compute_boundary_condition_residual","text":"compute_boundary_condition_residual(field, field_type::FieldType)\n\nCompute residual to check how well boundary conditions are satisfied.\n\nReturns a measure of how much the current field violates the boundary conditions. Useful for monitoring solution quality and debugging.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.copy_boundary_conditions!-Tuple{Any, Any, Geodynamo.BoundaryConditions.FieldType}","page":"API Reference","title":"Geodynamo.BoundaryConditions.copy_boundary_conditions!","text":"copy_boundary_conditions!(dest_field, src_field, field_type::FieldType)\n\nCopy boundary conditions from one field to another.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.create_boundary_data-Union{Tuple{T}, Tuple{Array{T}, String}} where T","page":"API Reference","title":"Geodynamo.BoundaryConditions.create_boundary_data","text":"create_boundary_data(values::Array{T}, field_type::String; \n                    theta=nothing, phi=nothing, time=nothing,\n                    units=\"\", description=\"\", file_path=\"programmatic\") where T\n\nCreate a BoundaryData structure from raw data.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.create_composition_interpolation_cache-Tuple{Geodynamo.BoundaryConditions.BoundaryConditionSet, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.create_composition_interpolation_cache","text":"create_composition_interpolation_cache(boundary_set::BoundaryConditionSet, config)\n\nCreate interpolation cache for composition boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.create_hybrid_composition_boundaries-Tuple{String, Tuple, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.create_hybrid_composition_boundaries","text":"create_hybrid_composition_boundaries(file_spec::String, prog_spec::Tuple, config; swap_boundaries=false)\n\nCreate hybrid composition boundaries (one from file, one programmatic).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.create_hybrid_magnetic_boundaries-Tuple{String, Tuple, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.create_hybrid_magnetic_boundaries","text":"create_hybrid_magnetic_boundaries(file_spec::String, prog_spec::Tuple, config; swap_boundaries=false)\n\nCreate hybrid magnetic boundaries (one from file, one programmatic).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.create_hybrid_temperature_boundaries-Tuple{String, Tuple, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.create_hybrid_temperature_boundaries","text":"create_hybrid_temperature_boundaries(file_spec::String, prog_spec::Tuple, config; swap_boundaries=false)\n\nCreate hybrid temperature boundaries (one from file, one programmatic).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.create_hybrid_velocity_boundaries-Tuple{String, Tuple, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.create_hybrid_velocity_boundaries","text":"create_hybrid_velocity_boundaries(file_spec::String, prog_spec::Tuple, config; swap_boundaries=false)\n\nCreate hybrid velocity boundaries (one from file, one programmatic).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.create_interpolation_cache-Union{Tuple{T}, Tuple{Geodynamo.BoundaryConditions.BoundaryData, Vector{T}, Vector{T}}} where T","page":"API Reference","title":"Geodynamo.BoundaryConditions.create_interpolation_cache","text":"create_interpolation_cache(boundary_data::BoundaryData, target_theta::Vector{T}, \n                          target_phi::Vector{T}) where T\n\nCreate interpolation cache for efficient repeated interpolations.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.create_layered_composition_boundary-Tuple{Any, Vector{Tuple{Real, Real, Real}}}","page":"API Reference","title":"Geodynamo.BoundaryConditions.create_layered_composition_boundary","text":"create_layered_composition_boundary(config, layer_specs::Vector{Tuple{Real, Real, Real}})\n\nCreate layered composition boundary conditions.\n\nArguments\n\nlayer_specs: Vector of (colatitudestart, colatitudeend, composition) tuples\n\nExample\n\n# Create three-layer composition structure\nlayer_specs = [\n    (0.0, π/3, 0.8),     # High composition in top layer\n    (π/3, 2π/3, 0.4),    # Medium composition in middle layer  \n    (2π/3, π, 0.1)       # Low composition in bottom layer\n]\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.create_layered_temperature_boundary-Tuple{Any, Vector{Tuple{Real, Real, Real}}}","page":"API Reference","title":"Geodynamo.BoundaryConditions.create_layered_temperature_boundary","text":"create_layered_temperature_boundary(config, layer_specs::Vector{Tuple{Real, Real, Real}})\n\nCreate layered temperature boundary conditions.\n\nArguments\n\nlayer_specs: Vector of (colatitudestart, colatitudeend, temperature) tuples\n\nExample\n\n# Create three-layer temperature structure\nlayer_specs = [\n    (0.0, π/3, 1000.0),    # High temperature in top layer\n    (π/3, 2π/3, 500.0),   # Medium temperature in middle layer  \n    (2π/3, π, 100.0)      # Low temperature in bottom layer\n]\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.create_magnetic_interpolation_cache-Tuple{Geodynamo.BoundaryConditions.BoundaryConditionSet, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.create_magnetic_interpolation_cache","text":"create_magnetic_interpolation_cache(boundary_set::BoundaryConditionSet, config)\n\nCreate interpolation cache for magnetic boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.create_programmatic_boundary","page":"API Reference","title":"Geodynamo.BoundaryConditions.create_programmatic_boundary","text":"create_programmatic_boundary(pattern::Symbol, config, amplitude::Real=1.0;\n                            parameters::Dict=Dict(), description::String=\"\")\n\nCreate programmatically generated boundary conditions.\n\nAvailable patterns:\n\n:uniform - Uniform value\n:y11 - Y₁₁ spherical harmonic  \n:plume - Gaussian plume pattern\n:hemisphere - Hemispherical pattern\n:dipole - Dipolar pattern (Y₁₀)\n:quadrupole - Quadrupolar pattern\n:custom - User-defined function\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.BoundaryConditions.create_programmatic_composition_boundaries-Tuple{Tuple, Tuple, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.create_programmatic_composition_boundaries","text":"create_programmatic_composition_boundaries(inner_spec::Tuple, outer_spec::Tuple, config)\n\nCreate fully programmatic composition boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.create_programmatic_magnetic_boundaries-Tuple{Tuple, Tuple, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.create_programmatic_magnetic_boundaries","text":"create_programmatic_magnetic_boundaries(inner_spec::Tuple, outer_spec::Tuple, config)\n\nCreate fully programmatic magnetic boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.create_programmatic_magnetic_boundary","page":"API Reference","title":"Geodynamo.BoundaryConditions.create_programmatic_magnetic_boundary","text":"create_programmatic_magnetic_boundary(pattern::Symbol, config, amplitude::Real=1.0; \n                                    parameters::Dict=Dict())\n\nCreate programmatically generated magnetic boundary conditions.\n\nAvailable patterns:\n\n:insulating - Insulating boundary (Br = 0, ∂Btan/∂r = 0)\n:perfect_conductor - Perfect conductor (B_tan = 0)\n:dipole - Dipolar magnetic field pattern\n:quadrupole - Quadrupolar magnetic field pattern\n:potential_field - Potential field from spherical harmonic coefficients\n:uniform_field - Uniform magnetic field\n:custom - User-defined magnetic field function\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.BoundaryConditions.create_programmatic_temperature_boundaries-Tuple{Tuple, Tuple, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.create_programmatic_temperature_boundaries","text":"create_programmatic_temperature_boundaries(inner_spec::Tuple, outer_spec::Tuple, config)\n\nCreate fully programmatic temperature boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.create_programmatic_velocity_boundaries-Tuple{Tuple, Tuple, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.create_programmatic_velocity_boundaries","text":"create_programmatic_velocity_boundaries(inner_spec::Tuple, outer_spec::Tuple, config)\n\nCreate fully programmatic velocity boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.create_programmatic_velocity_boundary","page":"API Reference","title":"Geodynamo.BoundaryConditions.create_programmatic_velocity_boundary","text":"create_programmatic_velocity_boundary(pattern::Symbol, config, amplitude::Real=1.0; \n                                    parameters::Dict=Dict())\n\nCreate programmatically generated velocity boundary conditions.\n\nAvailable patterns:\n\n:no_slip - Zero velocity at boundary (amplitude ignored)\n:stress_free - Zero stress at boundary (amplitude ignored)  \n:uniform_rotation - Uniform rotation with angular velocity amplitude\n:differential_rotation - Differential rotation pattern\n:zonal_flow - Zonal (east-west) flow pattern\n:meridional_flow - Meridional (north-south) flow pattern\n:custom - User-defined velocity function\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.BoundaryConditions.create_temperature_interpolation_cache-Tuple{Geodynamo.BoundaryConditions.BoundaryConditionSet, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.create_temperature_interpolation_cache","text":"create_temperature_interpolation_cache(boundary_set::BoundaryConditionSet, config)\n\nCreate interpolation cache for temperature boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.create_time_dependent_programmatic_boundary-Tuple{Symbol, Any, Tuple{Real, Real}, Int64}","page":"API Reference","title":"Geodynamo.BoundaryConditions.create_time_dependent_programmatic_boundary","text":"create_time_dependent_programmatic_boundary(pattern::Symbol, config, time_span::Tuple{Real, Real}, \n                                           ntime::Int; amplitude::Real=1.0, \n                                           parameters::Dict=Dict(), description::String=\"\",\n                                           field_type::String=\"temperature\")\n\nCreate time-dependent programmatically generated boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.create_velocity_interpolation_cache-Tuple{Geodynamo.BoundaryConditions.BoundaryConditionSet, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.create_velocity_interpolation_cache","text":"create_velocity_interpolation_cache(boundary_set::BoundaryConditionSet, config)\n\nCreate interpolation cache for velocity boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.determine_field_type_from_name-Tuple{String}","page":"API Reference","title":"Geodynamo.BoundaryConditions.determine_field_type_from_name","text":"determine_field_type_from_name(field_name::String) -> FieldType\n\nDetermine field type from field name string.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.enforce_boundary_conditions_in_solution!-Tuple{Any, Any, Geodynamo.BoundaryConditions.FieldType}","page":"API Reference","title":"Geodynamo.BoundaryConditions.enforce_boundary_conditions_in_solution!","text":"enforce_boundary_conditions_in_solution!(solution, state, field_type::FieldType)\n\nEnforce boundary conditions in the solution vector after timestepping.\n\nThis function ensures that the solution satisfies the boundary conditions after each timestep, which may be necessary for certain discretization schemes.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.enforce_composition_bc_in_solution!-Tuple{Any, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.enforce_composition_bc_in_solution!","text":"enforce_composition_bc_in_solution!(solution, comp_field)\n\nEnforce composition boundary conditions in solution vector.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.enforce_magnetic_bc_in_solution!-Tuple{Any, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.enforce_magnetic_bc_in_solution!","text":"enforce_magnetic_bc_in_solution!(solution, magnetic_field)\n\nEnforce magnetic field boundary conditions in solution vector.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.enforce_magnetic_boundary_constraints!-Tuple{Any, Symbol}","page":"API Reference","title":"Geodynamo.BoundaryConditions.enforce_magnetic_boundary_constraints!","text":"enforce_magnetic_boundary_constraints!(magnetic_field, bc_type::Symbol)\n\nEnforce magnetic boundary condition constraints based on physics.\n\nBoundary condition types:\n\n:insulating - Insulating boundary: Jnormal = 0, ∇×Btangential = 0 (B_r ≠ 0)\n:perfect_conductor - Perfect conductor: Btangential = 0, Br free\n:potential_field - Potential field matching at boundary\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.enforce_temperature_bc_in_solution!-Tuple{Any, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.enforce_temperature_bc_in_solution!","text":"enforce_temperature_bc_in_solution!(solution, temp_field)\n\nEnforce temperature boundary conditions in solution vector.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.enforce_velocity_bc_in_solution!-Tuple{Any, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.enforce_velocity_bc_in_solution!","text":"enforce_velocity_bc_in_solution!(solution, velocity_field)\n\nEnforce velocity boundary conditions in solution vector.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.enforce_velocity_boundary_constraints!","page":"API Reference","title":"Geodynamo.BoundaryConditions.enforce_velocity_boundary_constraints!","text":"enforce_velocity_boundary_constraints!(velocity_field, bc_type::Symbol=:no_slip)\n\nEnforce specific velocity boundary constraints based on boundary condition type. Uses proper QST (Q-spheroidal-toroidal) decomposition from SHTnsKit.\n\nArguments\n\nvelocity_field: Velocity field structure with QST components\nbc_type: Type of boundary condition (:noslip, :stressfree, :custom)\n\nBoundary Condition Mapping:\n\nNo-slip: vr = vθ = v_φ = 0 → Q = S = T = 0 at boundaries\nStress-free: v_r = 0, tangential stress = 0 → Q = 0, ∂S/∂r = ∂T/∂r = 0\nImpermeable: v_r = 0 → Q = 0 at boundaries (S, T unconstrained)\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.BoundaryConditions.estimate_interpolation_error-Union{Tuple{T}, Tuple{Geodynamo.BoundaryConditions.BoundaryData, Vector{T}, Vector{T}}} where T","page":"API Reference","title":"Geodynamo.BoundaryConditions.estimate_interpolation_error","text":"estimate_interpolation_error(boundary_data::BoundaryData, target_theta::Vector{T}, \n                            target_phi::Vector{T}) where T\n\nEstimate interpolation error based on grid resolution differences.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.find_composition_boundary_time_index-Tuple{Geodynamo.BoundaryConditions.BoundaryConditionSet, Float64}","page":"API Reference","title":"Geodynamo.BoundaryConditions.find_composition_boundary_time_index","text":"find_composition_boundary_time_index(boundary_set::BoundaryConditionSet, current_time::Float64)\n\nFind the appropriate time index for the current simulation time.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.find_grid_indices-Union{Tuple{T}, Tuple{Vector{T}, T}} where T","page":"API Reference","title":"Geodynamo.BoundaryConditions.find_grid_indices","text":"find_grid_indices(coords::Vector{T}, target::T; is_periodic::Bool=false) where T\n\nFind the two surrounding indices in a coordinate array for interpolation. Handles periodic coordinates (e.g., longitude) if is_periodic=true.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.find_temperature_boundary_time_index-Tuple{Geodynamo.BoundaryConditions.BoundaryConditionSet, Float64}","page":"API Reference","title":"Geodynamo.BoundaryConditions.find_temperature_boundary_time_index","text":"find_temperature_boundary_time_index(boundary_set::BoundaryConditionSet, current_time::Float64)\n\nFind the appropriate time index for the current simulation time.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_boundary_condition_summary-Tuple{Any, Geodynamo.BoundaryConditions.FieldType}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_boundary_condition_summary","text":"get_boundary_condition_summary(field, field_type::FieldType)\n\nGet a summary of the current boundary condition state.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_boundary_data-Tuple{Any, Geodynamo.BoundaryConditions.FieldType}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_boundary_data","text":"get_boundary_data(field, field_type::FieldType)\n\nGet boundary data from field using unified interface with fallback support.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_boundary_statistics-Tuple{Geodynamo.BoundaryConditions.BoundaryData}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_boundary_statistics","text":"get_boundary_statistics(boundary_data::BoundaryData)\n\nGet statistical information about boundary data.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_cached_data-Union{Tuple{T}, Tuple{Geodynamo.BoundaryConditions.BoundaryCache{T}, String}} where T","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_cached_data","text":"get_cached_data(cache::BoundaryCache{T}, key::String) where T\n\nRetrieve cached boundary data.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_comm-Tuple{}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_comm","text":"get_comm()\n\nGet MPI communicator (with fallback).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_composition_boundary_data-Tuple{Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_composition_boundary_data","text":"get_composition_boundary_data(comp_field)\n\nGet boundary data from field or fallback cache.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_composition_time_index-Tuple{Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_composition_time_index","text":"get_composition_time_index(comp_field)\n\nGet current time index from field or fallback cache.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_current_boundaries-Tuple{Any, Geodynamo.BoundaryConditions.FieldType}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_current_boundaries","text":"get_current_boundaries(field, field_type::FieldType)\n\nGet current boundary values for any field type.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_current_composition_boundaries-Tuple{Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_current_composition_boundaries","text":"get_current_composition_boundaries(comp_field)\n\nGet current composition boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_current_magnetic_boundaries-Tuple{Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_current_magnetic_boundaries","text":"get_current_magnetic_boundaries(magnetic_field)\n\nGet current magnetic field boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_current_simulation_time-Tuple{Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_current_simulation_time","text":"get_current_simulation_time(solver_state)\n\nExtract current simulation time from solver state.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_current_temperature_boundaries-Tuple{Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_current_temperature_boundaries","text":"get_current_temperature_boundaries(temp_field)\n\nGet current temperature boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_current_velocity_boundaries-Tuple{Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_current_velocity_boundaries","text":"get_current_velocity_boundaries(velocity_field)\n\nGet current velocity boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_default_boundary_type-Tuple{Geodynamo.BoundaryConditions.FieldType, Geodynamo.BoundaryConditions.BoundaryLocation}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_default_boundary_type","text":"get_default_boundary_type(field_type::FieldType, location::BoundaryLocation) -> BoundaryType\n\nGet default boundary condition type for a field at a specific location.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_default_units-Tuple{Geodynamo.BoundaryConditions.FieldType}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_default_units","text":"get_default_units(field_type::FieldType) -> String\n\nGet default units for a field type.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_field_from_state-Tuple{Any, Geodynamo.BoundaryConditions.FieldType}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_field_from_state","text":"get_field_from_state(state, field_type::FieldType)\n\nExtract the appropriate field from simulation state.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_interpolation_statistics-Union{Tuple{T}, Tuple{Geodynamo.BoundaryConditions.BoundaryData, Array{T}}} where T","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_interpolation_statistics","text":"get_interpolation_statistics(boundary_data::BoundaryData, interpolated_data::Array{T}) where T\n\nCompute statistics comparing original and interpolated data.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_interpolation_weights-Union{Tuple{T}, Tuple{Vector{T}, T, Tuple{Int64, Int64}}} where T","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_interpolation_weights","text":"get_interpolation_weights(coords::Vector{T}, target::T, indices::Tuple{Int, Int}) where T\n\nCalculate interpolation weights for linear interpolation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_netcdf_file_info-Tuple{String}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_netcdf_file_info","text":"get_netcdf_file_info(filename::String)\n\nGet information about a NetCDF boundary condition file.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_nprocs-Tuple{}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_nprocs","text":"get_nprocs()\n\nGet number of MPI processes (with fallback).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_rank-Tuple{}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_rank","text":"get_rank()\n\nGet MPI rank (with fallback).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_temperature_boundary_data-Tuple{Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_temperature_boundary_data","text":"get_temperature_boundary_data(temp_field)\n\nGet boundary data from field.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_temperature_time_index-Tuple{Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_temperature_time_index","text":"get_temperature_time_index(temp_field)\n\nGet current time index from field.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.get_time_index-Tuple{Any, Geodynamo.BoundaryConditions.FieldType}","page":"API Reference","title":"Geodynamo.BoundaryConditions.get_time_index","text":"get_time_index(field, field_type::FieldType)\n\nGet current time index from field using unified interface with fallback support.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.infer_velocity_bc_type-Tuple{Geodynamo.BoundaryConditions.BoundaryData}","page":"API Reference","title":"Geodynamo.BoundaryConditions.infer_velocity_bc_type","text":"infer_velocity_bc_type(boundary::BoundaryData)\n\nInfer boundary condition type (Dirichlet or Neumann) from boundary metadata.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.initialize_boundary_conditions!-Tuple{Any, Geodynamo.BoundaryConditions.FieldType, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.initialize_boundary_conditions!","text":"initialize_boundary_conditions!(field, field_type::FieldType, config)\n\nInitialize boundary condition support for a field structure.\n\nAdds the necessary boundary condition fields to existing field structures without breaking compatibility with existing code.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.interpolate_boundary_to_grid-Union{Tuple{T}, Tuple{Geodynamo.BoundaryConditions.BoundaryData, Vector{T}, Vector{T}}, Tuple{Geodynamo.BoundaryConditions.BoundaryData, Vector{T}, Vector{T}, Int64}} where T","page":"API Reference","title":"Geodynamo.BoundaryConditions.interpolate_boundary_to_grid","text":"interpolate_boundary_to_grid(boundary_data::BoundaryData, target_theta::Vector{T}, \n                            target_phi::Vector{T}, time_index::Int=1) where T\n\nInterpolate boundary data to a target grid using bilinear interpolation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.interpolate_with_cache","page":"API Reference","title":"Geodynamo.BoundaryConditions.interpolate_with_cache","text":"interpolate_with_cache(boundary_data::BoundaryData, cache::Dict, time_index::Int=1)\n\nPerform interpolation using pre-computed cache for efficiency.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.BoundaryConditions.load_composition_boundaries_from_files-Tuple{String, String, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.load_composition_boundaries_from_files","text":"load_composition_boundaries_from_files(inner_file::String, outer_file::String, config)\n\nLoad composition boundary conditions from NetCDF files.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.load_composition_boundary_conditions!-Tuple{Any, Dict}","page":"API Reference","title":"Geodynamo.BoundaryConditions.load_composition_boundary_conditions!","text":"load_composition_boundary_conditions!(comp_field, boundary_specs::Dict)\n\nLoad composition boundary conditions from various sources.\n\nArguments\n\ncomp_field: SHTnsCompositionField structure\nboundary_specs: Dictionary specifying boundary sources\n\nExamples\n\n# NetCDF files for both boundaries\nboundary_specs = Dict(\n    :inner => \"cmb_composition.nc\",\n    :outer => \"surface_composition.nc\"\n)\n\n# Mixed NetCDF and programmatic\nboundary_specs = Dict(\n    :inner => \"cmb_composition.nc\", \n    :outer => (:uniform, 0.1)  # 10% concentration\n)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.load_magnetic_boundaries_from_files-Tuple{String, String, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.load_magnetic_boundaries_from_files","text":"load_magnetic_boundaries_from_files(inner_file::String, outer_file::String, config)\n\nLoad magnetic field boundary conditions from NetCDF files.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.load_magnetic_boundary_conditions!-Tuple{Any, Dict}","page":"API Reference","title":"Geodynamo.BoundaryConditions.load_magnetic_boundary_conditions!","text":"load_magnetic_boundary_conditions!(magnetic_field, boundary_specs::Dict)\n\nLoad magnetic field boundary conditions from various sources.\n\nArguments\n\nmagnetic_field: SHTnsMagneticField structure\nboundary_specs: Dictionary specifying boundary sources\n\nExamples\n\n# Insulating inner, potential field outer\nboundary_specs = Dict(\n    :inner => (:insulating, 0.0),\n    :outer => (:potential_field, \"geomagnetic_coefficients.nc\")\n)\n\n# Perfect conductor boundaries\nboundary_specs = Dict(\n    :inner => (:perfect_conductor, 0.0),\n    :outer => (:perfect_conductor, 0.0)\n)\n\n# NetCDF files for both boundaries\nboundary_specs = Dict(\n    :inner => \"cmb_magnetic.nc\",\n    :outer => \"surface_magnetic.nc\"\n)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.load_temperature_boundaries_from_files-Tuple{String, String, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.load_temperature_boundaries_from_files","text":"load_temperature_boundaries_from_files(inner_file::String, outer_file::String, config)\n\nLoad temperature boundary conditions from NetCDF files.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.load_temperature_boundary_conditions!-Tuple{Any, Dict}","page":"API Reference","title":"Geodynamo.BoundaryConditions.load_temperature_boundary_conditions!","text":"load_temperature_boundary_conditions!(temp_field, boundary_specs::Dict)\n\nLoad temperature boundary conditions from various sources.\n\nArguments\n\ntemp_field: SHTnsTemperatureField structure\nboundary_specs: Dictionary specifying boundary sources\n\nExamples\n\n# NetCDF files for both boundaries\nboundary_specs = Dict(\n    :inner => \"cmb_temperature.nc\",\n    :outer => \"surface_temperature.nc\"\n)\n\n# Mixed NetCDF and programmatic\nboundary_specs = Dict(\n    :inner => \"cmb_temperature.nc\", \n    :outer => (:uniform, 300.0)\n)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.load_velocity_boundaries_from_files-Tuple{String, String, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.load_velocity_boundaries_from_files","text":"load_velocity_boundaries_from_files(inner_file::String, outer_file::String, config)\n\nLoad velocity boundary conditions from NetCDF files.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.load_velocity_boundary_conditions!-Tuple{Any, Dict}","page":"API Reference","title":"Geodynamo.BoundaryConditions.load_velocity_boundary_conditions!","text":"load_velocity_boundary_conditions!(velocity_field, boundary_specs::Dict)\n\nLoad velocity boundary conditions from various sources.\n\nArguments\n\nvelocity_field: SHTnsVelocityField structure\nboundary_specs: Dictionary specifying boundary sources\n\nExamples\n\n# No-slip boundaries at both surfaces\nboundary_specs = Dict(\n    :inner => (:no_slip, 0.0),\n    :outer => (:no_slip, 0.0)\n)\n\n# Stress-free boundaries\nboundary_specs = Dict(\n    :inner => (:stress_free, 0.0),\n    :outer => (:stress_free, 0.0)\n)\n\n# NetCDF file for inner, no-slip for outer\nboundary_specs = Dict(\n    :inner => \"cmb_velocity.nc\",\n    :outer => (:no_slip, 0.0)\n)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.log_boundary_condition_status","page":"API Reference","title":"Geodynamo.BoundaryConditions.log_boundary_condition_status","text":"log_boundary_condition_status(state, rank::Int=0)\n\nLog the status of all boundary conditions in the simulation state.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.BoundaryConditions.magnetic_to_qst_coefficients-NTuple{4, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.magnetic_to_qst_coefficients","text":"magnetic_to_qst_coefficients(B_r, B_theta, B_phi, config)\n\nConvert physical magnetic field components to QST spectral coefficients.\n\nFor magnetic fields:\n\nQ: Radial component coefficients (B_r)\nS: Spheroidal tangential component coefficients\nT: Toroidal tangential component coefficients\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.print_boundary_data_info","page":"API Reference","title":"Geodynamo.BoundaryConditions.print_boundary_data_info","text":"print_boundary_data_info(boundary_data::BoundaryData, prefix::String=\"\")\n\nPrint detailed information about boundary data.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.BoundaryConditions.print_boundary_info-Tuple{Geodynamo.BoundaryConditions.BoundaryConditionSet}","page":"API Reference","title":"Geodynamo.BoundaryConditions.print_boundary_info","text":"print_boundary_info(boundary_set::BoundaryConditionSet)\n\nPrint comprehensive information about a boundary condition set.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.print_boundary_summary-Tuple{Any, Geodynamo.BoundaryConditions.FieldType}","page":"API Reference","title":"Geodynamo.BoundaryConditions.print_boundary_summary","text":"print_boundary_summary(field, field_type::FieldType)\n\nPrint a summary of loaded boundary conditions for any field type.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.read_netcdf_boundary_data-Union{Tuple{String}, Tuple{T}} where T","page":"API Reference","title":"Geodynamo.BoundaryConditions.read_netcdf_boundary_data","text":"read_netcdf_boundary_data(filename::String; precision::Type{T}=Float64) where T\n\nRead boundary condition data from a NetCDF file.\n\nReturns a BoundaryData structure containing all boundary information.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.reset_boundary_conditions!-Tuple{Any, Geodynamo.BoundaryConditions.FieldType}","page":"API Reference","title":"Geodynamo.BoundaryConditions.reset_boundary_conditions!","text":"reset_boundary_conditions!(field, field_type::FieldType)\n\nReset/clear boundary conditions for a field.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.set_programmatic_composition_boundaries!-Tuple{Any, Tuple, Tuple}","page":"API Reference","title":"Geodynamo.BoundaryConditions.set_programmatic_composition_boundaries!","text":"set_programmatic_composition_boundaries!(comp_field, inner_spec::Tuple, outer_spec::Tuple)\n\nSet programmatic composition boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.set_programmatic_magnetic_boundaries!-Tuple{Any, Tuple, Tuple}","page":"API Reference","title":"Geodynamo.BoundaryConditions.set_programmatic_magnetic_boundaries!","text":"set_programmatic_magnetic_boundaries!(magnetic_field, inner_spec::Tuple, outer_spec::Tuple)\n\nSet programmatic magnetic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.set_programmatic_temperature_boundaries!-Tuple{Any, Tuple, Tuple}","page":"API Reference","title":"Geodynamo.BoundaryConditions.set_programmatic_temperature_boundaries!","text":"set_programmatic_temperature_boundaries!(temp_field, inner_spec::Tuple, outer_spec::Tuple)\n\nSet programmatic temperature boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.set_programmatic_velocity_boundaries!-Tuple{Any, Tuple, Tuple}","page":"API Reference","title":"Geodynamo.BoundaryConditions.set_programmatic_velocity_boundaries!","text":"set_programmatic_velocity_boundaries!(velocity_field, inner_spec::Tuple, outer_spec::Tuple)\n\nSet programmatic velocity boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.shtns_physical_to_spectral-Union{Tuple{T}, Tuple{Matrix{T}, Any}} where T","page":"API Reference","title":"Geodynamo.BoundaryConditions.shtns_physical_to_spectral","text":"shtns_physical_to_spectral(physical_data::Matrix{T}, config) where T\n\nTransform physical boundary data to spectral coefficients using SHTnsKit. This is a common utility function used by both thermal and composition modules.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.smooth_boundary_data-Tuple{Geodynamo.BoundaryConditions.BoundaryData, Real}","page":"API Reference","title":"Geodynamo.BoundaryConditions.smooth_boundary_data","text":"smooth_boundary_data(boundary_data::BoundaryData, smoothing_radius::Real)\n\nApply spatial smoothing to boundary data.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.spherical_harmonic-Tuple{Int64, Int64, Real, Real}","page":"API Reference","title":"Geodynamo.BoundaryConditions.spherical_harmonic","text":"spherical_harmonic(l::Int, m::Int, theta::Real, phi::Real)\n\nCompute spherical harmonic Y_l^m(θ, φ).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.spherical_harmonic_phi_derivative-Tuple{Int64, Int64, Real, Real}","page":"API Reference","title":"Geodynamo.BoundaryConditions.spherical_harmonic_phi_derivative","text":"spherical_harmonic_phi_derivative(l::Int, m::Int, theta::Real, phi::Real)\n\nCompute ∂Y_l^m/∂φ.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.spherical_harmonic_theta_derivative-Tuple{Int64, Int64, Real, Real}","page":"API Reference","title":"Geodynamo.BoundaryConditions.spherical_harmonic_theta_derivative","text":"spherical_harmonic_theta_derivative(l::Int, m::Int, theta::Real, phi::Real)\n\nCompute ∂Y_l^m/∂θ.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.update_boundary_conditions_for_timestep!-Tuple{Any, Float64}","page":"API Reference","title":"Geodynamo.BoundaryConditions.update_boundary_conditions_for_timestep!","text":"update_boundary_conditions_for_timestep!(state, current_time::Float64)\n\nUpdate all boundary conditions for the current timestep.\n\nThis function should be called at the beginning of each timestep to ensure all fields have up-to-date boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.update_composition_time_index!-Tuple{Any, Int64}","page":"API Reference","title":"Geodynamo.BoundaryConditions.update_composition_time_index!","text":"update_composition_time_index!(comp_field, time_index::Int)\n\nUpdate time index in field or fallback cache.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.update_temperature_time_index!-Tuple{Any, Int64}","page":"API Reference","title":"Geodynamo.BoundaryConditions.update_temperature_time_index!","text":"update_temperature_time_index!(temp_field, time_index::Int)\n\nUpdate time index in field.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.update_time_dependent_boundaries!-Tuple{Any, Geodynamo.BoundaryConditions.FieldType, Float64}","page":"API Reference","title":"Geodynamo.BoundaryConditions.update_time_dependent_boundaries!","text":"update_time_dependent_boundaries!(field, field_type::FieldType, current_time::Float64)\n\nUpdate time-dependent boundary conditions for any field type.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.update_time_dependent_composition_boundaries!-Tuple{Any, Float64}","page":"API Reference","title":"Geodynamo.BoundaryConditions.update_time_dependent_composition_boundaries!","text":"update_time_dependent_composition_boundaries!(comp_field, current_time::Float64)\n\nUpdate time-dependent composition boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.update_time_dependent_magnetic_boundaries!-Tuple{Any, Float64}","page":"API Reference","title":"Geodynamo.BoundaryConditions.update_time_dependent_magnetic_boundaries!","text":"update_time_dependent_magnetic_boundaries!(magnetic_field, current_time::Float64)\n\nUpdate time-dependent magnetic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.update_time_dependent_temperature_boundaries!-Tuple{Any, Float64}","page":"API Reference","title":"Geodynamo.BoundaryConditions.update_time_dependent_temperature_boundaries!","text":"update_time_dependent_temperature_boundaries!(temp_field, current_time::Float64)\n\nUpdate time-dependent temperature boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.update_time_dependent_velocity_boundaries!-Tuple{Any, Float64}","page":"API Reference","title":"Geodynamo.BoundaryConditions.update_time_dependent_velocity_boundaries!","text":"update_time_dependent_velocity_boundaries!(velocity_field, current_time::Float64)\n\nUpdate time-dependent velocity boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.validate_boundary_compatibility-Tuple{Geodynamo.BoundaryConditions.BoundaryData, Geodynamo.BoundaryConditions.BoundaryData, String}","page":"API Reference","title":"Geodynamo.BoundaryConditions.validate_boundary_compatibility","text":"validate_boundary_compatibility(inner::BoundaryData, outer::BoundaryData, field_name::String)\n\nValidate that inner and outer boundary data are compatible.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.validate_boundary_files-Tuple{Geodynamo.BoundaryConditions.FieldType, Dict, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.validate_boundary_files","text":"validate_boundary_files(field_type::FieldType, boundary_specs::Dict, config)\n\nValidate boundary condition files for any field type.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.validate_composition_boundary_files-Tuple{Dict, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.validate_composition_boundary_files","text":"validate_composition_boundary_files(boundary_specs::Dict, config)\n\nValidate composition boundary condition files.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.validate_composition_range-Tuple{Geodynamo.BoundaryConditions.BoundaryData}","page":"API Reference","title":"Geodynamo.BoundaryConditions.validate_composition_range","text":"validate_composition_range(boundary_data::BoundaryData)\n\nValidate that composition values are in the physical range [0, 1].\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.validate_field_boundary_compatibility-Tuple{Any, Geodynamo.BoundaryConditions.FieldType, Geodynamo.BoundaryConditions.BoundaryConditionSet}","page":"API Reference","title":"Geodynamo.BoundaryConditions.validate_field_boundary_compatibility","text":"validate_field_boundary_compatibility(field, field_type::FieldType, boundary_set::BoundaryConditionSet)\n\nValidate that a field structure is compatible with boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.validate_interpolation_grids-NTuple{4, Vector}","page":"API Reference","title":"Geodynamo.BoundaryConditions.validate_interpolation_grids","text":"validate_interpolation_grids(src_theta::Vector, src_phi::Vector, \n                            tgt_theta::Vector, tgt_phi::Vector)\n\nValidate that source and target grids are compatible for interpolation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.validate_magnetic_boundary_files-Tuple{Dict, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.validate_magnetic_boundary_files","text":"validate_magnetic_boundary_files(boundary_specs::Dict, config)\n\nValidate magnetic field boundary condition files.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.validate_netcdf_boundary_file","page":"API Reference","title":"Geodynamo.BoundaryConditions.validate_netcdf_boundary_file","text":"validate_netcdf_boundary_file(filename::String, required_vars::Vector{String}=[])\n\nValidate that a NetCDF boundary condition file has the required structure.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.BoundaryConditions.validate_temperature_boundary_files-Tuple{Dict, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.validate_temperature_boundary_files","text":"validate_temperature_boundary_files(boundary_specs::Dict, config)\n\nValidate temperature boundary condition files.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.validate_temperature_range-Tuple{Geodynamo.BoundaryConditions.BoundaryData}","page":"API Reference","title":"Geodynamo.BoundaryConditions.validate_temperature_range","text":"validate_temperature_range(boundary_data::BoundaryData)\n\nValidate that temperature values are in a reasonable physical range.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.validate_velocity_boundary_files-Tuple{Dict, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.validate_velocity_boundary_files","text":"validate_velocity_boundary_files(boundary_specs::Dict, config)\n\nValidate velocity boundary condition files.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.velocity_to_qst_coefficients-NTuple{4, Any}","page":"API Reference","title":"Geodynamo.BoundaryConditions.velocity_to_qst_coefficients","text":"velocity_to_qst_coefficients(v_r, v_theta, v_phi, config)\n\nConvert physical velocity components (vr, vθ, v_φ) to QST spectral coefficients by using proper SHTnsKit decomposition.\n\nThe QST decomposition used by SHTnsKit:\n\nQ: Radial component coefficients (transforms like scalar field)\nS: Spheroidal horizontal component coefficients (curl-free part)\nT: Toroidal horizontal component coefficients (divergence-free part)\n\nArguments\n\nv_r: Radial velocity component [nlat, nlon]\nv_theta: Colatitude velocity component [nlat, nlon]\nv_phi: Azimuthal velocity component [nlat, nlon]\nconfig: SHTnsKit configuration\n\nReturns\n\n(Q_coeffs, S_coeffs, T_coeffs): QST spectral coefficients\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.BoundaryConditions.write_netcdf_boundary_data-Tuple{String, Geodynamo.BoundaryConditions.BoundaryData}","page":"API Reference","title":"Geodynamo.BoundaryConditions.write_netcdf_boundary_data","text":"write_netcdf_boundary_data(filename::String, boundary_data::BoundaryData)\n\nWrite boundary condition data to a NetCDF file.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Initial-Conditions","page":"API Reference","title":"Initial Conditions","text":"","category":"section"},{"location":"api.html#Geodynamo.InitialConditions","page":"API Reference","title":"Geodynamo.InitialConditions","text":"InitialConditions\n\nModule for loading and generating initial conditions for geodynamo simulations. Supports loading from NetCDF files, generating random fields, and setting prescribed analytical patterns.\n\n\n\n\n\n","category":"module"},{"location":"api.html#Geodynamo.InitialConditions.generate_random_composition!-Tuple{Any, Any, Any}","page":"API Reference","title":"Geodynamo.InitialConditions.generate_random_composition!","text":"generate_random_composition!(comp_field, amplitude, modes_range)\n\nGenerate random composition initial conditions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.InitialConditions.generate_random_initial_conditions!-Tuple{Any, Symbol}","page":"API Reference","title":"Geodynamo.InitialConditions.generate_random_initial_conditions!","text":"generate_random_initial_conditions!(field, field_type::Symbol;\n                                   amplitude=1.0, modes_range=1:10,\n                                   seed=nothing)\n\nGenerate random initial conditions for any field type.\n\nArguments\n\nfield: Field structure to initialize\nfield_type: Type of field (:temperature, :magnetic, :velocity, :composition)\namplitude: Overall amplitude of random perturbations\nmodes_range: Range of spherical harmonic modes to excite\nseed: Random seed for reproducibility (optional)\n\nExamples\n\n# Random temperature field\ngenerate_random_initial_conditions!(temp_field, :temperature, amplitude=0.1)\n\n# Random magnetic field with specific modes\ngenerate_random_initial_conditions!(mag_field, :magnetic,\n                                   amplitude=0.01, modes_range=1:20, seed=42)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.InitialConditions.generate_random_magnetic!-Tuple{Any, Any, Any}","page":"API Reference","title":"Geodynamo.InitialConditions.generate_random_magnetic!","text":"generate_random_magnetic!(mag_field, amplitude, modes_range)\n\nGenerate random magnetic initial conditions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.InitialConditions.generate_random_temperature!-Tuple{Any, Any, Any}","page":"API Reference","title":"Geodynamo.InitialConditions.generate_random_temperature!","text":"generate_random_temperature!(temp_field, amplitude, modes_range)\n\nGenerate random temperature initial conditions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.InitialConditions.generate_random_velocity!-Tuple{Any, Any, Any}","page":"API Reference","title":"Geodynamo.InitialConditions.generate_random_velocity!","text":"generate_random_velocity!(vel_field, amplitude, modes_range)\n\nGenerate random velocity initial conditions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.InitialConditions.load_composition_initial_conditions!-Tuple{Any, String}","page":"API Reference","title":"Geodynamo.InitialConditions.load_composition_initial_conditions!","text":"load_composition_initial_conditions!(comp_field, file_path::String)\n\nLoad composition initial conditions from NetCDF file.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.InitialConditions.load_initial_conditions!-Tuple{Any, Symbol, String}","page":"API Reference","title":"Geodynamo.InitialConditions.load_initial_conditions!","text":"load_initial_conditions!(field, field_type::Symbol, file_path::String)\n\nLoad initial conditions from NetCDF file for any field type.\n\nArguments\n\nfield: Field structure (temperature, magnetic, velocity, or composition type)\nfield_type: Field type (:temperature, :magnetic, :velocity, :composition)\nfile_path: Path to NetCDF file containing initial conditions\n\nFile Format\n\nNetCDF files should contain:\n\nFor scalar fields: spectral coefficients array\nFor vector fields: toroidal and poloidal spectral coefficients\nCoordinate arrays: lm indices, radial grid\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.InitialConditions.load_magnetic_initial_conditions!-Tuple{Any, String}","page":"API Reference","title":"Geodynamo.InitialConditions.load_magnetic_initial_conditions!","text":"load_magnetic_initial_conditions!(mag_field, file_path::String)\n\nLoad magnetic initial conditions from NetCDF file.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.InitialConditions.load_temperature_initial_conditions!-Tuple{Any, String}","page":"API Reference","title":"Geodynamo.InitialConditions.load_temperature_initial_conditions!","text":"load_temperature_initial_conditions!(temp_field, file_path::String)\n\nLoad temperature initial conditions from NetCDF file.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.InitialConditions.load_velocity_initial_conditions!-Tuple{Any, String}","page":"API Reference","title":"Geodynamo.InitialConditions.load_velocity_initial_conditions!","text":"load_velocity_initial_conditions!(vel_field, file_path::String)\n\nLoad velocity initial conditions from NetCDF file.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.InitialConditions.randomize_magnetic_field!-Tuple{Any}","page":"API Reference","title":"Geodynamo.InitialConditions.randomize_magnetic_field!","text":"randomize_magnetic_field!(field; amplitude, lmax, domain=nothing)\n\nPopulate magnetic toroidal/poloidal fields with random perturbations.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.InitialConditions.randomize_scalar_field!-Tuple{Any}","page":"API Reference","title":"Geodynamo.InitialConditions.randomize_scalar_field!","text":"randomize_scalar_field!(field; amplitude, lmax, domain=nothing)\n\nPopulate a scalar spectral field (temperature/composition) with random perturbations up to degree lmax. If a radial domain is provided and includes r=0, ball regularity is enforced.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.InitialConditions.randomize_vector_field!-Tuple{Any}","page":"API Reference","title":"Geodynamo.InitialConditions.randomize_vector_field!","text":"randomize_vector_field!(field; amplitude, lmax, domain=nothing)\n\nPopulate velocity-like toroidal/poloidal fields with random perturbations up to degree lmax.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.InitialConditions.save_initial_conditions-Tuple{Any, Symbol, String}","page":"API Reference","title":"Geodynamo.InitialConditions.save_initial_conditions","text":"save_initial_conditions(field, field_type::Symbol, file_path::String)\n\nSave current field state as initial conditions to NetCDF file.\n\nThis function is useful for saving generated or computed initial conditions for later use in simulations.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.InitialConditions.set_analytical_composition!-Tuple{Any, Symbol, Any}","page":"API Reference","title":"Geodynamo.InitialConditions.set_analytical_composition!","text":"set_analytical_composition!(comp_field, pattern, amplitude; parameters...)\n\nSet analytical composition patterns.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.InitialConditions.set_analytical_initial_conditions!-Tuple{Any, Symbol, Symbol}","page":"API Reference","title":"Geodynamo.InitialConditions.set_analytical_initial_conditions!","text":"set_analytical_initial_conditions!(field, field_type::Symbol, pattern::Symbol;\n                                  amplitude=1.0, parameters...)\n\nSet analytical initial conditions based on predefined patterns.\n\nPatterns\n\n:conductive - Conductive temperature profile\n:dipole - Dipolar magnetic field\n:convective - Small convective velocity pattern\n:stratified - Stratified composition profile\n\nExamples\n\n# Conductive temperature profile\nset_analytical_initial_conditions!(temp_field, :temperature, :conductive)\n\n# Earth-like dipolar magnetic field\nset_analytical_initial_conditions!(mag_field, :magnetic, :dipole, amplitude=1.0)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.InitialConditions.set_analytical_magnetic!-Tuple{Any, Symbol, Any}","page":"API Reference","title":"Geodynamo.InitialConditions.set_analytical_magnetic!","text":"set_analytical_magnetic!(mag_field, pattern, amplitude; parameters...)\n\nSet analytical magnetic field patterns.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.InitialConditions.set_analytical_temperature!-Tuple{Any, Symbol, Any}","page":"API Reference","title":"Geodynamo.InitialConditions.set_analytical_temperature!","text":"set_analytical_temperature!(temp_field, pattern, amplitude; parameters...)\n\nSet analytical temperature patterns.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.InitialConditions.set_analytical_velocity!-Tuple{Any, Symbol, Any}","page":"API Reference","title":"Geodynamo.InitialConditions.set_analytical_velocity!","text":"set_analytical_velocity!(vel_field, pattern, amplitude; parameters...)\n\nSet analytical velocity patterns.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Spherical-Shell-Geometry","page":"API Reference","title":"Spherical Shell Geometry","text":"","category":"section"},{"location":"api.html#Geodynamo.GeodynamoShell.apply_shell_composition_boundaries!-Tuple{Any, Any}","page":"API Reference","title":"Geodynamo.GeodynamoShell.apply_shell_composition_boundaries!","text":"apply_shell_composition_boundaries!(comp_field, boundary_set; time=0)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoShell.apply_shell_temperature_boundaries!-Tuple{Any, Any}","page":"API Reference","title":"Geodynamo.GeodynamoShell.apply_shell_temperature_boundaries!","text":"apply_shell_temperature_boundaries!(temp_field, boundary_set; time=0)\n\nWrapper around core NetCDF boundary application for shell geometry.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoShell.create_shell_composition_field-Union{Tuple{T}, Tuple{Type{T}, SHTnsKitConfig}} where T","page":"API Reference","title":"Geodynamo.GeodynamoShell.create_shell_composition_field","text":"create_shell_composition_field(T, cfg::ShellConfig; nr=Geodynamo.i_N)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoShell.create_shell_hybrid_composition_boundaries-Union{Tuple{T}, Tuple{Any, Any, SHTnsKitConfig}} where T","page":"API Reference","title":"Geodynamo.GeodynamoShell.create_shell_hybrid_composition_boundaries","text":"create_shell_hybrid_composition_boundaries(inner_spec, outer_spec, cfg::ShellConfig; precision=Float64)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoShell.create_shell_hybrid_temperature_boundaries-Union{Tuple{T}, Tuple{Any, Any, SHTnsKitConfig}} where T","page":"API Reference","title":"Geodynamo.GeodynamoShell.create_shell_hybrid_temperature_boundaries","text":"create_shell_hybrid_temperature_boundaries(inner_spec, outer_spec, cfg::ShellConfig; precision=Float64)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoShell.create_shell_magnetic_fields-Union{Tuple{T}, Tuple{Type{T}, SHTnsKitConfig}} where T","page":"API Reference","title":"Geodynamo.GeodynamoShell.create_shell_magnetic_fields","text":"create_shell_magnetic_fields(T, cfg::ShellConfig; nr_oc=Geodynamo.i_N, nr_ic=Geodynamo.i_Nic)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoShell.create_shell_pencils-Tuple{SHTnsKitConfig}","page":"API Reference","title":"Geodynamo.GeodynamoShell.create_shell_pencils","text":"create_shell_pencils(cfg::ShellConfig; optimize=true)\n\nCreate a shell-oriented pencil decomposition using the core topology helper.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoShell.create_shell_physical_field-Union{Tuple{T}, Tuple{Type{T}, SHTnsKitConfig, RadialDomain, Any}} where T","page":"API Reference","title":"Geodynamo.GeodynamoShell.create_shell_physical_field","text":"create_shell_physical_field(T, cfg::ShellConfig, domain::Geodynamo.RadialDomain, pencil)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoShell.create_shell_radial_domain","page":"API Reference","title":"Geodynamo.GeodynamoShell.create_shell_radial_domain","text":"create_shell_radial_domain(nr=i_N) -> RadialDomain\n\nCreate a radial domain suitable for a spherical shell using the global parameter d_rratio for inner radius ratio. This is a thin wrapper over Geodynamo.create_radial_domain.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.GeodynamoShell.create_shell_spectral_field-Union{Tuple{T}, Tuple{Type{T}, SHTnsKitConfig, RadialDomain, Any}} where T","page":"API Reference","title":"Geodynamo.GeodynamoShell.create_shell_spectral_field","text":"create_shell_spectral_field(T, cfg::ShellConfig, domain::Geodynamo.RadialDomain, pencil)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoShell.create_shell_temperature_field-Union{Tuple{T}, Tuple{Type{T}, SHTnsKitConfig}} where T","page":"API Reference","title":"Geodynamo.GeodynamoShell.create_shell_temperature_field","text":"create_shell_temperature_field(T, cfg::ShellConfig; nr=Geodynamo.i_N)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoShell.create_shell_vector_field-Union{Tuple{T}, Tuple{Type{T}, SHTnsKitConfig, RadialDomain, Any}} where T","page":"API Reference","title":"Geodynamo.GeodynamoShell.create_shell_vector_field","text":"create_shell_vector_field(T, cfg::ShellConfig, domain::Geodynamo.RadialDomain, pencils)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoShell.create_shell_velocity_fields-Union{Tuple{T}, Tuple{Type{T}, SHTnsKitConfig}} where T","page":"API Reference","title":"Geodynamo.GeodynamoShell.create_shell_velocity_fields","text":"create_shell_velocity_fields(T, cfg::ShellConfig; nr=Geodynamo.i_N)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Solid-Ball-Geometry","page":"API Reference","title":"Solid Ball Geometry","text":"","category":"section"},{"location":"api.html#Geodynamo.GeodynamoBall.apply_ball_composition_regularity!-Tuple{Any}","page":"API Reference","title":"Geodynamo.GeodynamoBall.apply_ball_composition_regularity!","text":"apply_ball_composition_regularity!(comp_field)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoBall.apply_ball_temperature_regularity!-Tuple{Any}","page":"API Reference","title":"Geodynamo.GeodynamoBall.apply_ball_temperature_regularity!","text":"apply_ball_temperature_regularity!(temp_field)\n\nConvenience to enforce scalar regularity on the temperature spectral field. Call after assembling or updating temp_field.spectral.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoBall.ball_physical_to_spectral!-Union{Tuple{T}, Tuple{SHTnsPhysicalField{T}, SHTnsSpectralField{T}}} where T","page":"API Reference","title":"Geodynamo.GeodynamoBall.ball_physical_to_spectral!","text":"ball_physical_to_spectral!(phys::Geodynamo.SHTnsPhysicalField,\n                           spec::Geodynamo.SHTnsSpectralField)\n\nWrapper for transforms in a solid sphere that enforces scalar regularity at r=0 after analysis. Use this for scalar fields (temperature, composition, etc.).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoBall.ball_vector_analysis!-Union{Tuple{T}, Tuple{SHTnsVectorField{T}, SHTnsSpectralField{T}, SHTnsSpectralField{T}}} where T","page":"API Reference","title":"Geodynamo.GeodynamoBall.ball_vector_analysis!","text":"ball_vector_analysis!(vec::Geodynamo.SHTnsVectorField,\n                      tor::Geodynamo.SHTnsSpectralField,\n                      pol::Geodynamo.SHTnsSpectralField)\n\nWrapper for vector analysis in a solid sphere; enforces vector regularity at r=0 after transforming to spectral toroidal/poloidal.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoBall.create_ball_composition_field-Union{Tuple{T}, Tuple{Type{T}, SHTnsKitConfig}} where T","page":"API Reference","title":"Geodynamo.GeodynamoBall.create_ball_composition_field","text":"create_ball_composition_field(T, cfg::BallConfig; nr=Geodynamo.i_N)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoBall.create_ball_hybrid_composition_boundaries-Union{Tuple{T}, Tuple{Any, Any, SHTnsKitConfig}} where T","page":"API Reference","title":"Geodynamo.GeodynamoBall.create_ball_hybrid_composition_boundaries","text":"create_ball_hybrid_composition_boundaries(inner_spec, outer_spec, cfg::BallConfig; precision=Float64)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoBall.create_ball_hybrid_temperature_boundaries-Union{Tuple{T}, Tuple{Any, Any, SHTnsKitConfig}} where T","page":"API Reference","title":"Geodynamo.GeodynamoBall.create_ball_hybrid_temperature_boundaries","text":"create_ball_hybrid_temperature_boundaries(inner_spec, outer_spec, cfg::BallConfig; precision=Float64)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoBall.create_ball_magnetic_fields-Union{Tuple{T}, Tuple{Type{T}, SHTnsKitConfig}} where T","page":"API Reference","title":"Geodynamo.GeodynamoBall.create_ball_magnetic_fields","text":"create_ball_magnetic_fields(T, cfg::BallConfig; nr=Geodynamo.i_N)\n\nCreate magnetic fields for a solid sphere. Since a \"core\" split is not used in a ball, we pass the same domain for both oc and ic to reuse the core implementation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoBall.create_ball_pencils-Tuple{SHTnsKitConfig}","page":"API Reference","title":"Geodynamo.GeodynamoBall.create_ball_pencils","text":"create_ball_pencils(cfg::BallConfig; optimize=true)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoBall.create_ball_physical_field-Union{Tuple{T}, Tuple{Type{T}, SHTnsKitConfig, RadialDomain, Any}} where T","page":"API Reference","title":"Geodynamo.GeodynamoBall.create_ball_physical_field","text":"create_ball_physical_field(T, cfg::BallConfig, domain::Geodynamo.RadialDomain, pencil)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoBall.create_ball_radial_domain","page":"API Reference","title":"Geodynamo.GeodynamoBall.create_ball_radial_domain","text":"create_ball_radial_domain(nr=i_N) -> RadialDomain\n\nCreate a radial domain for a solid sphere (inner radius = 0). Uses a cosine-stretched grid similar to the shell for compatibility, but sets the inner radius to zero and adjusts the coordinate columns to match expectations of downstream operators.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Geodynamo.GeodynamoBall.create_ball_spectral_field-Union{Tuple{T}, Tuple{Type{T}, SHTnsKitConfig, RadialDomain, Any}} where T","page":"API Reference","title":"Geodynamo.GeodynamoBall.create_ball_spectral_field","text":"create_ball_spectral_field(T, cfg::BallConfig, domain::Geodynamo.RadialDomain, pencil)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoBall.create_ball_temperature_field-Union{Tuple{T}, Tuple{Type{T}, SHTnsKitConfig}} where T","page":"API Reference","title":"Geodynamo.GeodynamoBall.create_ball_temperature_field","text":"create_ball_temperature_field(T, cfg::BallConfig; nr=Geodynamo.i_N)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoBall.create_ball_vector_field-Union{Tuple{T}, Tuple{Type{T}, SHTnsKitConfig, RadialDomain, Any}} where T","page":"API Reference","title":"Geodynamo.GeodynamoBall.create_ball_vector_field","text":"create_ball_vector_field(T, cfg::BallConfig, domain::Geodynamo.RadialDomain, pencils)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoBall.create_ball_velocity_fields-Union{Tuple{T}, Tuple{Type{T}, SHTnsKitConfig}} where T","page":"API Reference","title":"Geodynamo.GeodynamoBall.create_ball_velocity_fields","text":"create_ball_velocity_fields(T, cfg::BallConfig; nr=Geodynamo.i_N)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoBall.enforce_ball_scalar_regularity!-Tuple{SHTnsSpectralField}","page":"API Reference","title":"Geodynamo.GeodynamoBall.enforce_ball_scalar_regularity!","text":"enforce_ball_scalar_regularity!(spec::Geodynamo.SHTnsSpectralField)\n\nEnforce scalar regularity at r=0 for solid sphere: for l>0, the scalar amplitude must vanish at r=0. Sets inner radial plane to zero for all nonzero l modes (both real and imaginary parts).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Geodynamo.GeodynamoBall.enforce_ball_vector_regularity!-Tuple{SHTnsSpectralField, SHTnsSpectralField}","page":"API Reference","title":"Geodynamo.GeodynamoBall.enforce_ball_vector_regularity!","text":"enforce_ball_vector_regularity!(tor_spec::Geodynamo.SHTnsSpectralField,\n                                pol_spec::Geodynamo.SHTnsSpectralField)\n\nEnforce vector-field regularity at r=0 for solid sphere. For smooth fields, both toroidal and poloidal potentials behave like r^{l+1}, so they vanish at r=0 for all l ≥ 1. Zeros the inner radial plane for l≥1.\n\n\n\n\n\n","category":"method"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"For lower-level packages used internally (SHTnsKit, PencilArrays, MPI), refer to their respective documentation.","category":"page"},{"location":"getting-started.html#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"This quick-start guide walks through preparing the environment, running the sample simulation, and inspecting the first output files. It assumes familiarity with Julia's package manager and a working MPI installation.","category":"page"},{"location":"getting-started.html#1.-Install-Julia-and-MPI","page":"Getting Started","title":"1. Install Julia & MPI","text":"","category":"section"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Install Julia 1.10 or 1.11 from julialang.org/downloads.\nInstall an MPI distribution (OpenMPI, MPICH, Intel MPI). Ensure mpiexec is on your PATH.\nOn macOS/Linux you might also need NetCDF libraries (libnetcdf, libnetcdff) for output. Package managers usually provide them (brew install netcdf, apt install libnetcdf-dev).","category":"page"},{"location":"getting-started.html#2.-Clone-the-Repository","page":"Getting Started","title":"2. Clone the Repository","text":"","category":"section"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"$ git clone https://github.com/subhk/Geodynamo.jl\n$ cd Geodynamo.jl","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"If you are working in a monorepo that already contains SHTnsKit, keep the sibling directory ../SHTnsKit.jl checked out so Geodynamo can develop against the local copy.","category":"page"},{"location":"getting-started.html#3.-Instantiate-the-Environment","page":"Getting Started","title":"3. Instantiate the Environment","text":"","category":"section"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Run the following once to download dependencies and build MPI/SHTnsKit artefacts:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"julia --project -e 'using Pkg; Pkg.instantiate(); Pkg.precompile()'","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"For development, it is convenient to activate the environment inside the Julia REPL:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"julia> using Pkg\njulia> Pkg.activate(\".\")\n[ Info: activating project at /path/to/Geodynamo.jl\njulia> Pkg.instantiate()","category":"page"},{"location":"getting-started.html#4.-Verify-SHTnsKit-and-MPI","page":"Getting Started","title":"4. Verify SHTnsKit & MPI","text":"","category":"section"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Before launching full simulations, confirm the angular transforms and MPI topology are functioning:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"julia --project test/shtnskit_roundtrip.jl","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Or launch the package test-suite (requires MPI to be initialised correctly):","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"$ julia --project -e 'using Pkg; Pkg.test(\"Geodynamo\")'","category":"page"},{"location":"getting-started.html#5.-Minimal-Example","page":"Getting Started","title":"5. Minimal Example","text":"","category":"section"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"julia> using Geodynamo\n\njulia> params = GeodynamoParameters(\n           geometry = :shell,\n           i_N = 64,\n           i_L = 31,\n           i_M = 31,\n           d_E = 1e-4,\n           d_Ra = 1e6,\n           d_Pr = 1.0,\n           d_Pm = 1.0,\n           i_B = 1,\n           output_precision = :float32,\n           independent_output_files = true,\n       );\n\njulia> set_parameters!(params);   # push to global configuration\n\njulia> state = initialize_simulation(Float64);\n\njulia> run_simulation!(state; t_end = 0.02)\n\n# Save parameters for reproducibility\njulia> save_parameters(params, \"config/run_local_shell.jl\");","category":"page"},{"location":"getting-started.html#Running-with-MPI","page":"Getting Started","title":"Running with MPI","text":"","category":"section"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Launch the same setup on four processes:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"mpiexec -n 4 julia --project -e 'using Geodynamo; state = initialize_simulation(Float64); run_simulation!(state; t_end = 0.02)'","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"The driver will write NetCDF files into ./output/ (see the Output guide for details). When running under MPI, start the executable with mpiexec and the desired number of ranks.","category":"page"},{"location":"getting-started.html#6.-What-the-Solver-Advances","page":"Getting Started","title":"6. What the Solver Advances","text":"","category":"section"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Geodynamo.jl integrates the nondimensional Boussinesq MHD system from Sreenivasan & Kar (2024), Eqs. (1)–(4). In magnetic-diffusion units the fields satisfy","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"fracEmathrmPmfracpartial boldsymbolupartial t\n  + (nabla times boldsymbolu) times boldsymbolu\n  + hatboldsymbolz times boldsymbolu\n  = -nabla p^star\n    + fracmathrmPmmathrmPr mathrmRaTboldsymbolr\n    + (nabla times boldsymbolB) times boldsymbolB\n    + E nabla^2 boldsymbolu","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"with thermal and magnetic evolution,","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"fracpartial Tpartial t + boldsymbolu cdot nabla T = fracmathrmPmmathrmPr nabla^2 T qquad\nfracpartial boldsymbolBpartial t = nabla times (boldsymbolu times boldsymbolB) + nabla^2 boldsymbolB","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"and solenoidality constraints ∇·u = ∇·B = 0. The code automatically applies the published prefactors—no additional scaling is required from the user beyond specifying (E, Pm, Pr, Ra, …) in GeodynamoParameters.","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Both u and B are represented spectrally via toroidal (T) and poloidal (P) potentials (u = ∇×(T \\hat{r}) + ∇×∇×(P \\hat{r}), and likewise for B). This guarantees divergence-free fields while keeping the spherical-harmonic bookkeeping minimal; the helper functions in InitialConditions.jl operate directly on these toroidal/poloidal coefficients.","category":"page"},{"location":"getting-started.html#Boundary-Conditions","page":"Getting Started","title":"Boundary Conditions","text":"","category":"section"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"The default shell setup enforces:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Velocity: no-slip at both the inner-core boundary (ICB) and core-mantle boundary (CMB) when i_vel_bc = 1; use 2 for stress-free.\nTemperature: fixed values at each boundary (i_tmp_bc = 1). Mixed/flux conditions can be configured through the boundary files in config/.\nMagnetic field: electrically insulating boundaries, matching to potential fields outside the fluid shell.\nComposition (optional): Dirichlet when i_cmp_bc = 1.","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"To override boundary data, create files under config/boundaries/ (see comments in src/BoundaryConditions/ for formats) and load them with BoundaryConditions.load_boundary_conditions! before run_simulation!.","category":"page"},{"location":"getting-started.html#Initial-Conditions","page":"Getting Started","title":"Initial Conditions","text":"","category":"section"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Geodynamo provides helpers in InitialConditions.jl:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"using Geodynamo\n\nstate = initialize_simulation(Float64)\n\n# Simple conductive profile with random perturbations\nset_temperature_ic!(state.temperature; profile = :conductive)\nrandomize_scalar_field!(state.temperature; amplitude = 1e-3, rng = Random.default_rng())\n\n# Small random velocity and magnetic seeds\nrandomize_vector_field!(state.velocity.velocity; amplitude = 1e-4)\nrandomize_magnetic_field!(state.magnetic; amplitude = 1e-5)","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"You can also load spectral snapshots via load_initial_conditions! or restart files with read_restart!. Always reapply set_parameters! before initialising so the grid matches the data you load.","category":"page"},{"location":"getting-started.html#7.-Typical-Workflow","page":"Getting Started","title":"7. Typical Workflow","text":"","category":"section"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Create or load parameters (load_parameters, set_parameters!).\nSet boundary data if you need non-default conditions (BoundaryConditions.load_boundary_conditions!), otherwise the built-ins are applied.\nSpecify initial conditions using the helpers above or your own spectral fields.\nInitialise transforms (either create_shtnskit_config manually or let initialize_simulation handle it).\nAdvance in time with run_simulation! or step manually using the timestep utilities.\nInspect diagnostics from the NetCDF output, or use extras/spectral_to_physical.jl to convert files.\nRestart from saved state via read_restart! and resume the run.","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"For an overview of all configuration options, continue to Configuration & Parameters.","category":"page"},{"location":"developer.html#Developer-Guide","page":"Developer Guide","title":"Developer Guide","text":"","category":"section"},{"location":"developer.html#Repository-Layout","page":"Developer Guide","title":"Repository Layout","text":"","category":"section"},{"location":"developer.html","page":"Developer Guide","title":"Developer Guide","text":"Geodynamo.jl/\n├── src/\n│   ├── Geodynamo.jl          # module entry point & exports\n│   ├── fields.jl             # PencilArray-backed field types\n│   ├── shtnskit_transforms.jl# SHTnsKit configuration + FFT/transposes\n│   ├── timestep.jl           # CNAB2/EAB2/ERK2 integrators and Krylov tools\n│   ├── velocity.jl, ...      # Physics kernels and nonlinear terms\n│   ├── outputs_writer.jl     # NetCDF writer\n│   └── simulation.jl         # high-level driver/state orchestration\n├── docs/                     # Documenter configuration and Markdown pages\n├── extras/                   # CLI utilities (spectral ↔ physical conversion)\n├── test/                     # regression and unit tests\n└── config/                   # sample parameter files","category":"page"},{"location":"developer.html#Setting-Up-a-Dev-Environment","page":"Developer Guide","title":"Setting Up a Dev Environment","text":"","category":"section"},{"location":"developer.html","page":"Developer Guide","title":"Developer Guide","text":"$ git clone https://github.com/subhk/Geodynamo.jl\n$ cd Geodynamo.jl\n$ julia --project -e 'using Pkg; Pkg.develop(PackageSpec(path=\"../SHTnsKit.jl\")); Pkg.instantiate()'","category":"page"},{"location":"developer.html","page":"Developer Guide","title":"Developer Guide","text":"The command above ensures the local SHTnsKit checkout is used instead of the registry version. When working on MPI-dependent features, launch Julia with mpiexec:","category":"page"},{"location":"developer.html","page":"Developer Guide","title":"Developer Guide","text":"$ mpiexec -n 4 julia --project","category":"page"},{"location":"developer.html","page":"Developer Guide","title":"Developer Guide","text":"Inside the REPL activate the project and load utilities as needed (using Geodynamo).","category":"page"},{"location":"developer.html#Testing","page":"Developer Guide","title":"Testing","text":"","category":"section"},{"location":"developer.html","page":"Developer Guide","title":"Developer Guide","text":"Full suite: julia --project -e 'using Pkg; Pkg.test()'\nSingle file: run the script under test/ directly (e.g. test/shtnskit_roundtrip.jl).\nCI matrix: .github/workflows/ci.yml runs on Ubuntu (Julia 1.10/1.11), macOS, and Windows (Julia 1.11). Linux installs mpich/libnetcdf-dev, macOS uses Homebrew (open-mpi, netcdf), and Windows relies on Microsoft MPI via Chocolatey. The workflow caches Julia artifacts, instantiates the project, and executes Pkg.test().","category":"page"},{"location":"developer.html","page":"Developer Guide","title":"Developer Guide","text":"After adding new features make sure either the existing tests cover them or you extend the suite—GitHub Actions must remain green before merging.","category":"page"},{"location":"developer.html#Building-Documentation","page":"Developer Guide","title":"Building Documentation","text":"","category":"section"},{"location":"developer.html","page":"Developer Guide","title":"Developer Guide","text":"Documentation is built with Documenter.jl.","category":"page"},{"location":"developer.html","page":"Developer Guide","title":"Developer Guide","text":"$ julia --project=docs -e 'using Pkg; Pkg.instantiate()'\n$ julia --project=docs docs/make.jl","category":"page"},{"location":"developer.html","page":"Developer Guide","title":"Developer Guide","text":"The CI workflow publishes the generated site to gh-pages. To preview locally, open docs/build/index.html after running make.jl.","category":"page"},{"location":"developer.html#Boundary-Conditions","page":"Developer Guide","title":"Boundary Conditions","text":"","category":"section"},{"location":"developer.html","page":"Developer Guide","title":"Developer Guide","text":"Boundary definitions live under src/BoundaryConditions/. To add a new boundary type:","category":"page"},{"location":"developer.html","page":"Developer Guide","title":"Developer Guide","text":"Extend the relevant BoundaryConditions.* module to parse your data source.\nUpdate outputs_writer.jl if you want the new fields recorded in NetCDF.\nDocument the format in Data Output & Restart Files.","category":"page"},{"location":"developer.html#Coding-Guidelines","page":"Developer Guide","title":"Coding Guidelines","text":"","category":"section"},{"location":"developer.html","page":"Developer Guide","title":"Developer Guide","text":"Prefer mutating functions that update preallocated buffers; garbage hurt scaling.\nKeep new modules MPI-safe: ensure rank-local code runs without implicit reductions when independent_output_files = true.\nUse @inbounds only after profiling, and add high-level docstrings so Documenter can surface them.\nWhen exposing new functionality, add it to the exports in Geodynamo.jl and the API reference.","category":"page"},{"location":"developer.html#Contributing","page":"Developer Guide","title":"Contributing","text":"","category":"section"},{"location":"developer.html","page":"Developer Guide","title":"Developer Guide","text":"Fork the repository and create a feature branch.\nAdd tests (or docs) illustrating the behaviour.\nRun the test-suite and docs/make.jl.\nOpen a pull request describing motivation, approach, and validation.","category":"page"},{"location":"developer.html","page":"Developer Guide","title":"Developer Guide","text":"Bug reports and feature requests are welcome via GitHub issues. Include MPI size, SHTnsKit revision, and parameter files to help reproduce problems quickly.","category":"page"},{"location":"configuration.html#Configuration-and-Parameters","page":"Configuration","title":"Configuration & Parameters","text":"","category":"section"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"GeodynamoParameters collects every tunable knob controlling geometry, resolution, physics, and time-stepping. This page explains how the fields fit together and provides guidance for common setups.","category":"page"},{"location":"configuration.html#Geodynamo.GeodynamoParameters","page":"Configuration","title":"Geodynamo.GeodynamoParameters","text":"GeodynamoParameters\n\nStructure to hold all simulation parameters. This replaces the global constants from the old params.jl file with a more flexible parameter system.\n\n\n\n\n\n","category":"type"},{"location":"configuration.html#Geometry-and-Resolution","page":"Configuration","title":"Geometry & Resolution","text":"","category":"section"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"Field Meaning Notes\ngeometry :shell or :ball Drives boundary conditions, initialisation, and diagnostic logic.\ni_N Radial grid points Applies to both outer-core (oc_domain) and inner-core (ic_domain) grids.\ni_L, i_M Maximum spherical harmonic degree/order Communicated to SHTnsKit. i_M defaults to i_L.\ni_Th, i_Ph Physical θ/φ grid resolution Overridden by SHTnsKit heuristics if incompatible with gauss grids.\ni_KL Radial finite-difference bandwidth Controls stencil width for derivative operators.","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"In practice, choose i_L ≈ i_N for balanced spectral/radial workload, and scale i_Th, i_Ph so SHTnsKit can allocate Gauss–Legendre grid points (nlat ≥ i_L + 2, nlon ≥ 2*i_L + 1).","category":"page"},{"location":"configuration.html#Physical-Parameters","page":"Configuration","title":"Physical Parameters","text":"","category":"section"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"Field Description\nd_rratio Inner-to-outer radius ratio (shell runs).\nd_Ra, d_Ra_C Thermal and compositional Rayleigh numbers.\nd_E, d_Pr, d_Pm, d_Sc Ekman, Prandtl, magnetic Prandtl, Schmidt.\nd_Ro, d_q Rossby number (informational; solver derives Pm/E internally) and thermal diffusivity ratio.\nb_mag_impose, i_B Flags for imposed background fields and enabling magnetic evolution.","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"These directly scale the nondimensionalised MHD equations summarised on the overview page.","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"note: Rossby prefactor\nWhen advancing Eq. (1) the code computes the Rossby prefactor as d_Pm / d_E (the ratio ( \\mathrm{Pm}/E )) so that the time derivative matches the (E/\\mathrm{Pm}) mass matrix in the published formulation. The d_Ro parameter is retained for backwards compatibility but is not used during timestepping.","category":"page"},{"location":"configuration.html#Time-Integration","page":"Configuration","title":"Time Integration","text":"","category":"section"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"Field Meaning\nts_scheme :cnab2, :eab2, or :erk2.\nd_timestep Base Δt. Adjusts CFL and ETD caches.\nd_time Initial simulation clock.\nd_implicit θ parameter for CNAB2 implicit solve (θ = 0.5 → Crank–Nicolson).\nd_dterr Error tolerance for adaptive stepping (future use).\nd_courant CFL safety factor used by compute_cfl_timestep!.\ni_etd_m, d_krylov_tol Arnoldi dimension and residual tolerance for ETD/EAB2/ERK2 Krylov actions.","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"See Time Integration for scheme-specific details and recommended values.","category":"page"},{"location":"configuration.html#Boundary-Conditions","page":"Configuration","title":"Boundary Conditions","text":"","category":"section"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"Boundary options are set through the integer selectors in GeodynamoParameters and, optionally, via external files loaded through the BoundaryConditions module.","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"Field Meaning Built-in options\ni_vel_bc Velocity boundary type 1 no-slip (default), 2 stress-free.\ni_tmp_bc Temperature BC 1 fixed temperature. Flux/mixed profiles can be supplied via boundary files.\ni_cmp_bc Composition BC 1 fixed composition.\ni_poloidal_stress_iters Extra iterations enforcing stress-free poloidal constraints Increase when using i_vel_bc = 2.","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"When a boundary file is present under config/boundaries/<field>_boundary.nc (or a custom path passed to BoundaryConditions.load_boundary_conditions!), those data override the analytic defaults. Each file provides spherical-harmonic coefficients for the inner and outer surfaces together with a type flag per mode (DIRICHLET, NEUMANN, ROBIN). See the docstrings in src/BoundaryConditions/ for field-specific formats.","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"After loading parameters, call:","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"using Geodynamo\nGeodynamo.BoundaryConditions.load_boundary_conditions!(\n    velocity = \"config/boundaries/velocity_default.nc\",\n    temperature = \"config/boundaries/thermal_flux.nc\",\n)","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"before creating the simulation state so the coefficients are cached in spectral space.","category":"page"},{"location":"configuration.html#Initial-Conditions-and-Restarts","page":"Configuration","title":"Initial Conditions & Restarts","text":"","category":"section"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"The InitialConditions module offers high-level helpers:","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"Function Purpose\nset_velocity_initial_conditions! Deterministic poloidal/toroidal seeds (solid-body, dipole, etc.).\nrandomize_vector_field! Add random divergence-free perturbations.\nset_temperature_ic!, set_composition_ic! Conductive, mixed, or user-defined radial profiles.\nrandomize_scalar_field! Thermal/compositional noise with configurable amplitude.\nload_initial_conditions!, save_initial_conditions Work with saved snapshots in NetCDF/HDF5.","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"A typical recipe is:","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"state = initialize_simulation(Float64)\nset_temperature_ic!(state.temperature; profile = :conductive)\nrandomize_scalar_field!(state.temperature; amplitude = 1e-3)\nset_velocity_initial_conditions!(state.velocity; kind = :rest)\nrandomize_magnetic_field!(state.magnetic; amplitude = 1e-5)","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"For reproducible continuation runs use write_restart! and read_restart!, which store the full spectral state together with time metadata.","category":"page"},{"location":"configuration.html#Output-and-Restart","page":"Configuration","title":"Output & Restart","text":"","category":"section"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"Field Meaning\noutput_precision :float32 or :float64 for NetCDF data.\nindependent_output_files When true each MPI rank writes its own (rank-indexed) files without synchronisation.\ni_save_rate2 Output cadence in steps (legacy). Prefer outputs_writer tracker for fine control.","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"Set output_precision = :float32 to halve disk usage; diagnostics remain in Float64 where accuracy is required.","category":"page"},{"location":"configuration.html#Managing-Parameters","page":"Configuration","title":"Managing Parameters","text":"","category":"section"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"julia> params = GeodynamoParameters(i_N = 96, i_L = 47, d_E = 3e-5);\n\njulia> set_parameters!(params);          # updates global state\n\njulia> save_parameters(params, \"config/run_highres.jl\")\n\njulia> params2 = load_parameters(\"config/run_highres.jl\");","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"All configuration files under config/ are plain Julia scripts assigning constants. They are parsed by load_parameters and can be version-controlled per experiment.","category":"page"},{"location":"configuration.html#Next-Steps","page":"Configuration","title":"Next Steps","text":"","category":"section"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"Time Integration – understand how the selected scheme uses the parameters above.\nData Output & Restart Files – tailor precision and I/O strategy to your cluster. \nDeveloper Guide – customise domain decompositions or add new physics modules.","category":"page"},{"location":"index.html#Geodynamo.jl","page":"Home","title":"Geodynamo.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"High-performance spherical-MHD solver for geodynamo and planetary-core studies built on SHTnsKit and PencilArrays","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Geodynamo.jl couples spectral spherical-harmonic transforms with domain-decomposed finite-difference operators to evolve the governing magnetohydrodynamic (MHD) equations for rapidly rotating planetary interiors. The code targets multi-node simulations, supports mixed toroidal/poloidal representations, and provides a modern Julia interface for extending dynamo studies.","category":"page"},{"location":"index.html#Why-Geodynamo.jl?","page":"Home","title":"Why Geodynamo.jl?","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"End-to-end MHD pipeline – temperature, composition, velocity, and magnetic sub-systems are advanced in a single, tightly coupled solver.\nHybrid spectral–radial discretisation – SHTnsKit supplies fast spherical harmonics while pencil-decomposed finite differences handle radial terms.\nTime integration options – CNAB2 IMEX, exponential AB2 (EAB2), and exponential RK2 (ERK2) schemes with Krylov-based linear operators.\nMPI-friendly I/O – each rank owns its checkpoint/output files with selectable precision (Float32/Float64) and NetCDF metadata.\nComposable Julia design – the module exposes field constructors, transform utilities, and workflow helpers for custom studies.","category":"page"},{"location":"index.html#Architecture-Overview","page":"Home","title":"Architecture Overview","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The main pieces of the package are:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"SHTnsKit transforms (shtnskit_transforms.jl) – wraps the SHTnsKit grid, FFT plans, and transpose operators.\nField abstractions (fields.jl) – PencilArray-backed spectral and physical fields with boundary metadata.\nTime integration (timestep.jl) – shared Krylov utilities, ETD caches, implicit solvers, and step orchestration helpers.\nPhysics kernels (velocity.jl, magnetic.jl, thermal.jl, compositional.jl) – compute nonlinear terms, boundary corrections, and diagnostics.\nSimulation driver (simulation.jl) – assembles components into SimulationState, manages timestepping, and coordinates output.\nI/O layer (outputs_writer.jl) – NetCDF writer with rank-scoped filenames, precision controls, and restart handling.","category":"page"},{"location":"index.html#Required-Dependencies","page":"Home","title":"Required Dependencies","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Layer Library Responsibility\nMessage passing MPI.jl Communicator management, collective reductions.\nPencil decomposition PencilArrays.jl & PencilFFTs.jl Domain decomposition, transpose plans, distributed FFTs.\nSpherical harmonics SHTnsKit.jl Gauss grids, spectral transforms, cached Legendre tables.\nI/O NetCDF.jl & HDF5.jl Structured output, restart files, metadata.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"These dependencies are pulled in automatically via the package manifest. You only need a working MPI implementation and NetCDF C libraries at runtime.","category":"page"},{"location":"index.html#Governing-Equations","page":"Home","title":"Governing Equations","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The solver advances the nondimensional Boussinesq MHD system presented in Sreenivasan & Kar, Phys. Rev. Fluids 9, 093801 (2024), Eqs. (1)–(4). In magnetic-diffusion units the equations read","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"beginaligned\nfracEmathrmPmfracpartial boldsymbolupartial t\n  + (nabla times boldsymbolu) times boldsymbolu\n  + hatboldsymbolz times boldsymbolu\n  = -nabla p^star\n     + fracmathrmPmmathrmPrmathrmRaTboldsymbolr\n     + (nabla times boldsymbolB) times boldsymbolB\n     + E nabla^2 boldsymbolu \nfracpartial Tpartial t + boldsymbolu cdot nabla T\n  = fracmathrmPmmathrmPr nabla^2 T \nfracpartial boldsymbolBpartial t\n  = nabla times (boldsymbolu times boldsymbolB) + nabla^2 boldsymbolB \nnabla cdot boldsymbolu = nabla cdot boldsymbolB = 0\nendaligned","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Internally we divide the momentum equation by E/Pm, so the CNAB2/ERK2/EAB2 integrators work with a unit mass matrix and a viscous operator scaled by Pm. Thermal and compositional diffusion use (Pm/Pr) and (Pm/Sc) respectively, while the induction equation diffuses with unit coefficient.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The solver stores both velocity and magnetic fields in a toroidal–poloidal decomposition, which enforces ∇·u = ∇·B = 0 spectrally. Each timestep reconstructs physical-space vectors through SHTnsKit transforms, evaluates nonlinear terms, and projects back to toroidal/poloidal coefficients before applying the implicit diffusive operators above.","category":"page"},{"location":"index.html#Documentation-Map","page":"Home","title":"Documentation Map","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The remainder of the docs walk you through the typical workflow:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Getting Started – installation, verifying the build, running the quick example.\nConfiguration & Parameters – how GeodynamoParameters map to grids, physics, and timestepping.\nTime Integration – CNAB2, EAB2, and ERK2 schemes, caches, and recommended settings.\nData Output & Restart Files – per-rank NetCDF layout, precision control, diagnostics, and boundary datasets.\nAPI Reference – automatically generated index of exported types and functions.\nDeveloper Guide – project layout, testing, documentation build, and contribution guidelines.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"If you are familiar with SHTnsKit itself, skim the configuration guide and jump straight to the timestepping section. Otherwise, start with Getting Started to ensure the MPI/SHTnsKit toolchain is correctly configured.","category":"page"},{"location":"index.html#Cite-and-Support","page":"Home","title":"Cite & Support","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If Geodynamo.jl supports your research, please cite the repository and consider opening an issue or PR with improvements. Community feedback is the fastest way to expand the physics modules and add new diagnostic hooks.","category":"page"},{"location":"index.html#Release-Cadence-and-Support-Matrix","page":"Home","title":"Release Cadence & Support Matrix","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Branch Status Julia Notes\nmain active development 1.10–1.11 Latest features, documentation builds on each push.\nrelease tags snapshots 1.10 Stable checkpoints for published results.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We run CI on Linux (OpenMPI) and macOS (MPICH). Contributions targeting other MPI distributions are welcome—check Developer Guide for instructions on adding regression tests.","category":"page"},{"location":"io.html#Data-Output-and-Restart-Files","page":"Data Output","title":"Data Output & Restart Files","text":"","category":"section"},{"location":"io.html","page":"Data Output","title":"Data Output","text":"Geodynamo.jl writes diagnostics, checkpoints, and restart files through the NetCDF-based outputs_writer.jl. The system is designed to scale with MPI: each rank writes only the data it owns, avoiding collective I/O bottlenecks.","category":"page"},{"location":"io.html#OutputConfig","page":"Data Output","title":"OutputConfig","text":"","category":"section"},{"location":"io.html","page":"Data Output","title":"Data Output","text":"The OutputConfig struct controls how data is written to NetCDF files. Create instances using:","category":"page"},{"location":"io.html","page":"Data Output","title":"Data Output","text":"default_config() - Creates default configuration\noutput_config_from_parameters() - Seeds from current GeodynamoParameters\nwith_output_precision(config, T) - Changes precision to type T\nwith_independent_writes(config, flag) - Enables/disables independent writes","category":"page"},{"location":"io.html","page":"Data Output","title":"Data Output","text":"Key flags:","category":"page"},{"location":"io.html","page":"Data Output","title":"Data Output","text":"output_precision – choose Float32 to reduce file size; metadata and diagnostics stay in Float64.\nindependent_writes – when true (default), every rank writes geodynamo_output_rank_XXXX_time_T.nc. Disable to enforce MPI.Barrier synchronisation at the cost of scalability.\noutput_dir / filename_prefix – location and prefix for both output and restart files.\ncompression_level – NetCDF deflate level (0 disables compression).","category":"page"},{"location":"io.html","page":"Data Output","title":"Data Output","text":"Use output_config_from_parameters() to seed an OutputConfig from the current GeodynamoParameters, then tweak it with with_output_precision or with_independent_writes.","category":"page"},{"location":"io.html#File-Layout","page":"Data Output","title":"File Layout","text":"","category":"section"},{"location":"io.html","page":"Data Output","title":"Data Output","text":"Each NetCDF file stores:","category":"page"},{"location":"io.html","page":"Data Output","title":"Data Output","text":"Coordinates: theta, phi, r, along with spherical-harmonic index arrays (l_values, m_values).\nSpectral fields: real/imaginary pairs for velocity (toroidal/poloidal), magnetic field, temperature, composition.\nPhysical fields: optional temperature/composition grids when output_space includes physical data.\nDiagnostics: scalar variables summarising energy, RMS, spectral peaks, etc.\nMetadata: geometry, MPI rank, wall-clock time, simulation step.","category":"page"},{"location":"io.html","page":"Data Output","title":"Data Output","text":"Per-rank files make post-processing easy—filter by rank_0003 to grab data from a specific MPI rank.","category":"page"},{"location":"io.html#NetCDF-Boundaries","page":"Data Output","title":"NetCDF Boundaries","text":"","category":"section"},{"location":"io.html","page":"Data Output","title":"Data Output","text":"Boundary conditions can also be sourced from NetCDF. The helper config/netcdf_boundaries.jl and the Boundary Conditions module understand files containing:","category":"page"},{"location":"io.html","page":"Data Output","title":"Data Output","text":"boundary_type (Dirichlet, Neumann, etc.)\ninner_values / outer_values\nTime-dependent series with interpolation metadata","category":"page"},{"location":"io.html","page":"Data Output","title":"Data Output","text":"Refer to docs/src/NETCDF_BOUNDARIES.jl (legacy) or the developer guide for template creation.","category":"page"},{"location":"io.html#Restart-Files","page":"Data Output","title":"Restart Files","text":"","category":"section"},{"location":"io.html","page":"Data Output","title":"Data Output","text":"write_restart! mirrors the output structure and adds restart-specific scalars (last_output_time, output_count, restart_count). Use read_restart! to populate a fresh SimulationState and TimeTracker:","category":"page"},{"location":"io.html","page":"Data Output","title":"Data Output","text":"restart_data, metadata = read_restart!(tracker, \"output\", 1.0, config)","category":"page"},{"location":"io.html#Tips","page":"Data Output","title":"Tips","text":"","category":"section"},{"location":"io.html","page":"Data Output","title":"Data Output","text":"Keep restart cadence (restart_interval) longer than output cadence unless you need frequent checkpoints.\nTo resume with new precision, load the restart and apply with_output_precision before continuing.\nMPI ranks search for files matching their rank_XXXX suffix; avoid manual renames.","category":"page"},{"location":"io.html#Diagnostics-and-Conversion","page":"Data Output","title":"Diagnostics & Conversion","text":"","category":"section"},{"location":"io.html","page":"Data Output","title":"Data Output","text":"The extras/spectral_to_physical.jl script converts spectral NetCDF files to physical grids in batch mode. Run it with:","category":"page"},{"location":"io.html","page":"Data Output","title":"Data Output","text":"julia --project extras/spectral_to_physical.jl --input output --output physical","category":"page"},{"location":"io.html","page":"Data Output","title":"Data Output","text":"The script honours the same precision flags and uses the stored SHTnsKit configuration to perform inverse transforms.","category":"page"}]
}
